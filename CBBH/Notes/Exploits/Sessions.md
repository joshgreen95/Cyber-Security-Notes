## Introduction to Sessions 
A user session can be defined as a sequence of requests originating from the same client and the ascosciated responses during a specific time period 
HTTP is a stateless communications protocol because of this we utilize cookies and session IDs

### Session Identifier Security 
a Session ID or token is the basis upon which users are distinguished.
If an attacker obtains a session ID we call this session hijacking where an attacker can impersonate a victim on a webapp.

A session identifier can  be:
- Captured through passive traffic/packet sniffing
- Identified in logs
- Predicted
- Brute Forced

Session identifiers security level depends on:
	*Validity Scope*: Secure Session Identifier should be valid for one session
	*Randomness*: Generated through secure algorithm and cant be predicted
	*Validity Time*: Should expire after a certain amount of time

Most programming languages have established session protocols that fit this.
If custom session protocol, proceed with caution and be as exhaustive as possible in testing.

*Places a seesion_id can be stored*
- `URL`: If this is the case, the HTTP _Referer_ header can leak a session identifier to other websites. In addition, browser history will also contain any session identifier stored in the URL.
- `HTML`: If this is the case, the session identifier can be identified in both the browser's cache memory and any intermediate proxies
- `sessionStorage`: SessionStorage is a browser storage feature introduced in HTML5. Session identifiers stored in sessionStorage can be retrieved as long as the tab or the browser is open. In other words, sessionStorage data gets cleared when the _page session_ ends. Note that a page session survives over page reloads and restores.
- `localStorage`: LocalStorage is a browser storage feature introduced in HTML5. Session identifiers stored in localStorage can be retrieved as long as localStorage does not get deleted by the user. This is because data stored within localStorage will not be deleted when the browser process is terminated, with the exception of "private browsing" or "incognito" sessions where data stored within localStorage are deleted by the time the last tab is closed.

### Session Attacks
- *Session Hijacking*: taking advantage or stealing session IDs to impersonate other users.
- *Session Fixation*: tricking victims to log in with valid session identifier.
- *XSS*: Can steal user cookies and session IDs
- *CSRF*: attack that forces an end-user to execute inadvertent actions on a web application in which they are currently authenticated
- *Open Redirect*: an attacker can redirect a victim to an attacker controlled website by abusing a legitimate apps redirect function. The attacker specifies the controlled website in the redirection URL and passes this to the victim.

## Session Hijacking
In a Session Hijacking attack, an attacker finds a way to obtain a session token and authenticate to the server as a victim.

An attacker could use different methods with the most common being 
- Passive Traffic Sniffing
- Cross-Site Scripting (XSS)
- Browser history or log-diving
- Read access to a database containing session information

Simply put, steal the cookie and login with it

## Session Fixation
When attacker tricks victim into logging into application using a session identifier.
Bugs usually occur when session identifiers are being accepted from URL Queries or POST data.

Session identifier will already be known. Usually done in 3 stages

#### Stage 1: Attacker manages to obtain a valid session identifier
Obtain valid session identifier without authentication. 
Attacker can also obtain a session identifier by creating an acount.

#### Stage 2: Attacker manages to fixate a valid session identifier
Stage 1 is expected behavior but can turn into session fixation if 
- The assigned session identifier pre-login remains the same post-login `and`
- Session identifiers (such as cookies) are being accepted from _URL Query Strings_ or _Post Data_ and propagated to the application

#### Step 3: Attacker tricks victim into establishing a session with the aforementioned identifier
An attacker has to craft a URL and have the victim visit it, if the victim does so then the web app will assign the session to the 

***Best way to test*** If there is a session identifier parameter in the URL 
*Another way of identifying this is via blindly putting the session identifier name and value in the URL and then refreshing.*


## Obtaining Session ID without User Interaction 
Multiple ways valid session identifier can be identified. 2 most common:
1. Session ID-obtaining attacks without user interaction
2. Session ID-obtaining attacks requiring user interaction

### Obtaining Session ID via Traffic Sniffing
Traffic sniffing is accessing the network from the inside via laptop/raspberry pi.
Requires victim and attacker to be on the same local network. 
`HTTP` traffic is encrypted so full requests can be read with WireShark with their HTTP filter
*Challening/Impossible to traffic sniff HTTPS

### Obtaining Session Identifiers Post-Exploitation
Once we gain access to a server there are several ways to enumerate session data.

#### PHP 
PHP session identifiers are stored in the path specified as `session.save_path` in the `php.ini` file
```shell-session
locate php.ini
cat /etc/php/7.4/cli/php.ini | grep 'session.save_path'
cat /etc/php/7.4/apache2/php.ini | grep 'session.save_path'
```

Once we find the session path we can then view our session files and it is usually stored as `sess_<SESSIONID>`

We could then find admin sessions, or create one and then assign it to our own session ID or create a new one.

#### JAVA
The `Manager` element represents the _session manager_ that is used to create and maintain HTTP sessions of a web application.

Tomcat provides two standard implementations of `Manager`. The default implementation stores active sessions, while the optional one stores active sessions that have been swapped out (in addition to saving sessions across a server restart) in a storage location that is selected via the use of an appropriate `Store` nested element. The filename of the default session data file is `SESSIONS.ser`.

#### .NET
Session data can be found in:
- The application worker process (aspnet_wp.exe) - This is the case in the _InProc Session mode_
- StateServer (A Windows Service residing on IIS or a separate server) - This is the case in the _OutProc Session mode_
- An SQL Server

#### Database access
databases can have references to sessions.

## XSS
XSS can be used to obtain valid credentials.
Get XSS to send document.getcookie() to server

Requirements
- Session Cookies should be carried by all HTTP requests
- Session cookies should be accessible by JS code (HTTP only attribute missing) *findable in httpOnly flag on storage*

possible to use nc to obtain session cookies by having src request carry document.cookie as concatenated string. 

## CSRF
an attack that forces users to preform inadvertent actions on a web page in which they are currently unauthenticated. Attack preformed with attacker crafted- website that victim must interact with. 
*Protect against with Same-Origin policy *

A web app is vulnerable to CSRF when;
- All the parameters required for target request can be determined or guessed by attacker
- The application's session management 

To successfully exploit a CSRF we need 
- To craft a malicious page that will issue a valid cross-site request to impersonate the victim
- The victim to be logged into the web app at the time the malicious request was issued
*look for no anti-CSRF token*

#### CSRF Get Based
With an unencrypted request we can extract CSRF tokens.

#### CSRF POST Based
Most apps nowadays preform actions through `POST` requests.

## XSS and CSRF chaining
We sometimes may not be able to create cross-site requests due to same origin restriction.
If this is the case we need to chain XSS and CSRF

Sites that possess anti csrf measures(through server-config, not possible to spot) and stored XSS

as malicious cross-site requests are blocked due to same origin protections we can still preform CSRF via XSS. 

```javascript
<script>
var req = new XMLHttpRequest();
req.onload = handleResponse;
req.open('get','/app/change-visibility',true);
req.send();
function handleResponse(d) {
    var token = this.responseText.match(/name="csrf" type="hidden" value="(\w+)"/)[1];
    var changeReq = new XMLHttpRequest();
    changeReq.open('post', '/app/change-visibility', true);
    changeReq.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    changeReq.send('csrf='+token+'&action=change');
};
```

We create a Javascript request that mimics the HTML request and then store that in a XSS

## Exploiting Weak CSRF Tokens
often webapps do not employ secure token generation algorithms.
often CSRF tokens are just hashed versions of usernames.

We can then just check if the md5 hash matches the username.

## Additional CSRF Protection Bypasses
- Making CSRF token null value %00
- Random CSRF token equal to length 
- Use another Sessions's CSRF token
- Delete the CSRF Token or send blank token

## Open Redirect 
An open redirect occurs when we can redirect a victim to an attacker-controlled website by abusing a legitimate applications redirect functionality.

Attacker specifies website under their control in a redirection of a legitimate website.
Useful to trick a victim into visiting a website through a website they trust.

The malicious URL an attacker would send leveraging the Open Redirect vulnerability would look as follows: `trusted.site/index.php?url=https://evil.com`

Make sure you check for the following URL parameters when bug hunting, you'll often see them in login pages. Example: `/login.php?redirect=dashboard`

- ?url=
- ?link=
- ?redirect=
- ?redirecturl=
- ?redirect_uri=
- ?return=
- ?return_to=
- ?returnurl=
- ?go=
- ?goto=
- ?exit=
- ?exitpage=
- ?fromurl=
- ?fromuri=
- ?redirect_to=
- ?next=
- ?newurl=
- ?redir=

