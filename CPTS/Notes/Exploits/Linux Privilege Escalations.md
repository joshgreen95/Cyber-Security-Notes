Things to look out for:
***OS Version***: Knowing the distro will give us an opportunity to look at which tools are available. 
***Kernel Version***: There may be publicly available exploits which target a specific kernel version 
***Running Services***: Knowing which services are running on the host are important. Especially important is services running as root `ps aux | grep root`
***Installed Packages and Package Versions***:  Out of date packages may be easy leveraged for privilege escalation.
***Logged In Users***: Knowing which users are logged in gives better ability for lateral movement. `ps au`
***User's  Home Directories***: `ls /home` check if user directories are readable and check for bash history or ssh keys
***Sudo Priveleges***: Check which commands the user can run as root `sudo -l`
***Password Hashes***: Check if we have access to `/etc/passwd` or `/etc/shadow`
***Cron Jobs***: Cron jobs/scheduled tasks can be ran as root and misconfigured.
***Unmounted File System***: Could possibly mount an unmounted file which may contain sensitive files/passwords `lsblk`.
***SETUID and GETUID Permissions***: Binaries are set with this value to allow to run a command as root without being ran as a root level user.
***Writeable Directories***: To find where to import and store tools.
***Writeable Files***: Are any scripts or config files world writeable? 

## Environment Enumeration
Enumeration is the key to privilege escalation and we can use a tool like *Linpeas*.

#### Typical Enumeration Commands
- `whoami` - what user are we running as
- `id` - what groups does our user belong to?
- `hostname` - what is the server named, can we gather anything from the naming convention?
- `ifconfig` or `ip -a` - what subnet did we land in, does the host have additional NICs in other subnets?
- `sudo -l` - can our user run anything with sudo (as another user as root) without needing a password? This can sometimes be the easiest win and we can do something like `sudo su` and drop right into a root shell.

*OS Release*: `cat /etc/os-release`
*Environment Variable*: `env` may hold passwords stored as environment variables.

## Linux Services and Enumeration
- What services and applications are installed?
- What services are running?
- What sockets are in use?
- What users, admins, and groups exist on the system?
- Who is current logged in? What users recently logged in?
- What password policies, if any, are enforced on the host?
- Is the host joined to an Active Directory domain?
- What types of interesting information can we find in history, log, and backup files
- Which files have been modified recently and how often? Are there any interesting patterns in file modification that could indicate a cron job in use that we may be able to hijack?
- Current IP addressing information
- Anything interesting in the `/etc/hosts` file?
- Are there any interesting network connections to other systems in the internal network or even outside the network?
- What tools are installed on the system that we may be able to take advantage of? (Netcat, Perl, Python, Ruby, Nmap, tcpdump, gcc, etc.)
- Can we access the `bash_history` file for any users and can we uncover any thing interesting from their recorded command line history such as passwords?
- Are any Cron jobs running on the system that we may be able to hijack?

### Internals
Internal configurations of integrated systems. 

*Network Interfaces*: `ip a`
*Hosts File*: `cat /etc/hosts`  ~Good idea to check last login to system and how frequently~
*Last Login*: `lastlog`
*Who else is on the system*: `finger` `w` 
*Command History*: `history`
*CronJobs*: `ls -la /etc/cron.daily/`
*Proc Filesystem*: ` find /proc -name cmdline -exec cat {} \; 2>/dev/null | tr " " "\n"`

### Services
Could find installed packages that may have a vulnerability. 
*Installed Packages*: `ls -la /etc/cron.daily/`
*Sudo*: Sudo may be vulnerable `sudo -V`
*Binaries*: `ls -l /bin /usr/bin/ /usr/sbin/`
*GTFObins*: Platform for checking vulnerable binaries 
```shell-session
for i in $(curl -s https://gtfobins.github.io/ | html2text | cut -d" " -f1 | sed '/^[[:space:]]*$/d');do if grep -q "$i" installed_pkgs.list;then echo "Check GTFO for: $i";fi;done
```

#### Strace 
We can use a tool like `strace` to find and analyze system  calls and signal processing. We can understand how it accesses system resources, processes signals, and receives and sends data from the operating system. 
```shell-session
strace ping -c1 10.129.112.20
```

#### Configuration Files
Users can read almost all config files on Linux. Can often reveal how a service is configured and may contain sensitive information.
```shell-session
find / -type f \( -name *.conf -o -name *.config \) -exec ls -l {} \; 2>/dev/null
```

Scripts created by admins may not have their rights restricted.
*Scripts*
```shell-session
find / -type f -name "*.sh" 2>/dev/null | grep -v "src\|snap\|share"
```

*Running Services*
```shell-session
ps aux | grep root
```

## Credential Hunting
When enumerating a system its important to note any credentials. These can be found in configuration files (`.conf, .xml, .config`), shell scripts, a user's bash history file, backup (`.bak`) files, within databases or text files.

*Web root my contain database credentials* 
```shell-session
cat wp-config.php | grep 'DB_USER\|DB_PASSWORD'
```

*the spool or webroot directories may contain valuable information*
```shell-session
find / ! -path "*/proc/*" -iname "*config*" -type f 2>/dev/null
```

#### SSH Keys
Its useful to search around the system for private SSH Keys
```shell-session
ls ~/.ssh
```

## Path Abuse
`PATH` is an environment variable that specifies the set of directories where an executable can be located. An accounts `PATH` variable is a set of absolute paths allowing user to type a command without specifying the absolute path to a binary. A user can type `cat /tmp/text.txt` instead of `/bin/cat /tmp/text.txt`.

We can check the contents of the `PATH` variable by typing `env | grep PATH` or `echo $PATH`

We can create a script or program in a directory specified in the `$PATH` will make it executable from any directory on the system.

Adding *.* to a user's `PATH` adds their current working directory to the list. If we can modify a users path we can replace a common binary like `ls` with a malicious script such as a reverse shell. if we add *.* to `PATH` by using the command
```
PATH=.:$PATH
export PATH
```
we will be able to run binaries in our local working directory. Now we can add a malicious script to our current working directory and when a user types `ls` it will call the malicious script in the current working directory.
