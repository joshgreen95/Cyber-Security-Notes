| Tool                                                                                                     | Description                                                                                                                                                                                                                                                                                                               |
| -------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| [Seatbelt](https://github.com/GhostPack/Seatbelt)                                                        | C# project for performing a wide variety of local privilege escalation checks                                                                                                                                                                                                                                             |
| [winPEAS](https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/tree/master/winPEAS) | WinPEAS is a script that searches for possible paths to escalate privileges on Windows hosts. All of the checks are explained [here](https://book.hacktricks.xyz/windows/checklist-windows-privilege-escalation)                                                                                                          |
| [PowerUp](https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Privesc/PowerUp.ps1)      | PowerShell script for finding common Windows privilege escalation vectors that rely on misconfigurations. It can also be used to exploit some of the issues found                                                                                                                                                         |
| [SharpUp](https://github.com/GhostPack/SharpUp)                                                          | C# version of PowerUp                                                                                                                                                                                                                                                                                                     |
| [JAWS](https://github.com/411Hall/JAWS)                                                                  | PowerShell script for enumerating privilege escalation vectors written in PowerShell 2.0                                                                                                                                                                                                                                  |
| [SessionGopher](https://github.com/Arvanaghi/SessionGopher)                                              | SessionGopher is a PowerShell tool that finds and decrypts saved session information for remote access tools. It extracts PuTTY, WinSCP, SuperPuTTY, FileZilla, and RDP saved session information                                                                                                                         |
| [Watson](https://github.com/rasta-mouse/Watson)                                                          | Watson is a .NET tool designed to enumerate missing KBs and suggest exploits for Privilege Escalation vulnerabilities.                                                                                                                                                                                                    |
| [LaZagne](https://github.com/AlessandroZ/LaZagne)                                                        | Tool used for retrieving passwords stored on a local machine from web browsers, chat tools, databases, Git, email, memory dumps, PHP, sysadmin tools, wireless network configurations, internal Windows password storage mechanisms, and more                                                                             |
| [Windows Exploit Suggester - Next Generation](https://github.com/bitsadmin/wesng)                        | WES-NG is a tool based on the output of Windows' `systeminfo` utility which provides the list of vulnerabilities the OS is vulnerable to, including any exploits for these vulnerabilities. Every Windows OS between Windows XP and Windows 10, including their Windows Server counterparts, is supported                 |
| [Sysinternals Suite](https://docs.microsoft.com/en-us/sysinternals/downloads/sysinternals-suite)         | We will use several tools from Sysinternals in our enumeration including [AccessChk](https://docs.microsoft.com/en-us/sysinternals/downloads/accesschk), [PipeList](https://docs.microsoft.com/en-us/sysinternals/downloads/pipelist), and [PsService](https://docs.microsoft.com/en-us/sysinternals/downloads/psservice) |
## Situational Awareness
Important to get lay of the land before we can exploit the system. 

### Network Information
Could be possible to find a *dual homed* server. *Dual-homed* means a device belongs to multiple different networks, this could have several virtual or physical network interfaces.
We should always check *routing tables*. 
We can gather information about local domain (ip of domain controllers). We can view the *arp* cache to see other domains that a computer has interacted with. 
Can help with lateral movement.

#### Interfaces, IP Addresses, DNS Information
```
ipconfig /all
```
#### ARP
```
arp -a
```
#### Routing Table
```
route print
```

### Enumerating Protections
Check for *Antivirus* and *End-Point Detection and Response* (`EDR`).
Will help us craft custom payloads or modify tools before compiling them.

Many organizations use a *whitelist* to control which types of applications certain users can run. This could be used to block non-admin users from running `cmd` and `powershell`.

Popular solution is [AppLocker](https://docs.microsoft.com/en-us/windows/security/threat-protection/windows-defender-application-control/applocker/applocker-overview) and we can use `GetAppLockerPolicy` cmdlet to enumerate the local, effective (enforced), and domain AppLocker policies. 

Early enumeration helps us combat *AV* and *EDR*.

#### Check Windows Defender Status
```
Get-MpComputerStatus
```

#### List AppLocker Rules
```
Get-AppLockerPolicy -Effective | select -ExpandProperty RuleCollections
```

#### Test Applocker Policy
```powershell-session
Get-AppLockerPolicy -Local | Test-AppLockerPolicy -path C:\Windows\System32\cmd.exe -User Everyone
```

### Initial Enumeration
During our testing we may gain access to a low-privileged shell on a windows domain and need to perform testing to further our access.
We can view sensitive files, capture traffic and view credentials which may help us further our access.

We can escalate privileges to one of the following depending on the system configuration and what type of data we encounter:

|   |
|---|
|The highly privileged `NT AUTHORITY\SYSTEM` account, or [LocalSystem](https://docs.microsoft.com/en-us/windows/win32/services/localsystem-account) account which is a highly privileged account with more privileges than a local administrator account and is used to run most Windows services.|
|The built-in local `administrator` account. Some organizations disable this account, but many do not. It is not uncommon to see this account reused across multiple systems in a client environment.|
|Another local account that is a member of the local `Administrators` group. Any account in this group will have the same privileges as the built-in `administrator` account.|
|A standard (non-privileged) domain user who is part of the local `Administrators` group.|
|A domain admin (highly privileged in the Active Directory environment) that is part of the local `Administrators` group.|
### Key Data Points
*OS name*: Knowing the OS and version will give us an idea of the types of tools that may be available. 
*Version*: May be publicly available exploits for the OS version.
*Running Services*: Knowing what services are running on the host is important, especially those running as `NT AUTHORITY\SYSTEM` or an administrator-level account. A misconfigured or vulnerable service running in the context of a privileged account can be an easy win for privilege escalation.

### System Information
Using [tasklist](https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/tasklist) command will give us a better idea of running applications.
```
tasklist /svc
```
It is essential to become familiar with standard Windows processes such as [Session Manager Subsystem (smss.exe)](https://en.wikipedia.org/wiki/Session_Manager_Subsystem), [Client Server Runtime Subsystem (csrss.exe)](https://en.wikipedia.org/wiki/Client/Server_Runtime_Subsystem), [WinLogon (winlogon.exe)](https://en.wikipedia.org/wiki/Winlogon), [Local Security Authority Subsystem Service (LSASS)](https://en.wikipedia.org/wiki/Local_Security_Authority_Subsystem_Service), and [Service Host (svchost.exe)](https://en.wikipedia.org/wiki/Svchost.exe)

### Display All Environment Variables
`PATH` variables infrequently changed but in the case of python/java may be changed to run commands.
We can view this using `set` its not infrequent to find.

### View Detailed Configuration Information
the `systeminfo` command will show if the box has been patched recently or is a vm.
possible to hide configuration settings from non-admin accounts.

### Patches and Updates
If `systeminfo` doesn't display hotfixes, they may be queriable with [WMI](https://docs.microsoft.com/en-us/windows/win32/wmisdk/wmi-start-page) using the *WMI-Command* binary with [QFE (Quick Fix Engineering)](https://docs.microsoft.com/en-us/windows/win32/cimwin32prov/win32-quickfixengineering)
```
wmic qfe
```
we can also do this with PowerShell using the `Get-Hotfix` cmdlet
```powershell-session
Get-HotFix | ft -AutoSize
```

### Installed Programs
WMI can also be used to display installed software. With this we can find hard exploits
Is `FileZilla`/`Putty`/etc installed? Run `LaZagne`
```cmd-session
wmic product get name
```

```powershell-session
Get-WmiObject -Class Win32_Product |  select Name, Version
```

### Display Running Processes
`netstat` will display active `TCP/UDP` connections. Could possibly find a vulnerable service.
```cmd-session
netstat -ano
```

### User and Group Information
Users are often the weakest link in an organization, especially when systems are configured and patched well. Can possibly find password files.

#### Logged-In Users
Always important to determine which users are logged in. 
Are they Idle or Active? Can we determine what they're working on?
During evasive engagements, we may need to tread lightly on a host with other users to avoid  messing with what they're working on.
```cmd-session
query user
```

#### Current User
When we gain access to a host, we should always check what context our user is running under. Sometimes we already have access to `SYSTEM` or equivalent. Some service accounts may have *SeImpersonatePrivilege*, which can be easily abused to escalate privs with [Juicy Potato](https://github.com/ohpe/juicy-potato)
```
echo %USERNAME%
```
##### Current User Privileges
```cmd-session
whoami /priv
```
##### Current Users Group Information
```cmd-session
whoami /groups
```

#### Get All Users
Knowing other users on the system is also important. If we gained RDP access to a host using credentials we captured for a user `bob`, and see a `bob_adm` user in the local administrators group, it is worth checking for credential re-use.
```cmd-session
net user
```
#### Get All Groups
Knowing what non-standard groups are present can help us find escalation vectors.
```cmd-session
net localgroup
```
#### Details About a Group
During our enumeration, we may discover credentials of another non-admin user who is a member of a local group that can be leveraged to escalate privileges.
```cmd-session
net localgroup administrators
```
#### Get Password Policy & Other Account Information
```cmd-session
net accounts
```

## Communication with Process
One of the best places to look for privilege escalation is the processes that are running on the system.
We could  place a web shell on the web server and gain a shell as the user running the web server.
Generally, this is not an administrator but will often have the `SeImpersonate` token, allowing for `Rogue/Juicy/Lonely Potato` to provide SYSTEM permissions.

### Access Tokens
Access tokens are used to describe security context of a process or thread. 
The token includes information about the user account's identity and privileges related to a specific process or thread.
When a user authenticates its password is checked against a security database, and if properly authenticated they will be assigned an access token.
Every time the user interacts with this process the token is presented again.

### Enumerating Network Services
The most common way people interact with processes is through a network socket (DNS, HTTP, SMB, etc.). The [netstat](https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/netstat) command will display active TCP and UDP connections
```
netstat -ano
```

The main thing to look for are entries listening on a loop back address *127.0.0.1* and *::1* that are not listening on the IP Address (`10.129.43.8`) or broadcast (`0.0.0.0`, `::/0`)
Network sockets for localhost are often overlooked and insecure as they're 'not accessible to the network'.

port `tcp 14147` used for filezillas admin panel.

### Named Pipes
Another way processes can communicate is named pipes.
Pipes are files stored in memory that get cleared after being read. Cobalt Strike uses pipes for every command (excluding [BOF](https://www.cobaltstrike.com/help-beacon-object-files)).

1. Beacon starts a named pipe of \.\pipe\msagent_12
2. Beacon starts a new process and injects command into that process directing output to \.\pipe\msagent_12
3. Server displays what was written into \.\pipe\msagent_12

There are two types of pipes, [named pipes](https://docs.microsoft.com/en-us/windows/win32/ipc/named-pipes) and anonymous pipes
Windows systems use client-server implementation for pipe communication. n this type of implementation, the process that creates a named pipe is the server, and the process communicating with the named pipe is the client. Named pipes can communicate using `half-duplex`, or a one-way channel with the client only being able to write data to the server, or `duplex`, which is a two-way communication channel that allows the client to write data over the pipe, and the server to respond back with data over that pipe. Every active connection to a named pipe server results in the creation of a new named pipe. These all share the same pipe name but communicate using a different data buffer.

We can use the tool `PipeList` from the *SysInternals Suite* to enumerate instances of named pipes.

### Listing Named Pipes with Pipelist
```cmd-session
pipelist.exe /accepteula
```

### Listing Pipes with Powershell
```powershell-session
gci \\.\pipe\
```

After obtaining a list of pipes we can use [Accesschk](https://docs.microsoft.com/en-us/sysinternals/downloads/accesschk) to enumerate permissions assigned to a specific named pipe by reviewing the *Discretionary Access List* (DACL) which shows us who has the permissions to modify, write, read, or execute a resourceWe can also review the DACLs of all named pipes using the command `.\accesschk.exe /accepteula \pipe\`.

### Reviewing LSASS Named Pipe Permissions
```cmd-session
accesschk.exe /accepteula \\.\Pipe\lsass -v
```

### Named Pipe Attack Example
This [WindscribeService Named Pipe Privilege Escalation](https://www.exploit-db.com/exploits/48021) is a great example. Using `accesschk` we can search for all named pipes that allow write access with a command such as `accesschk.exe -w \pipe\* -v` and notice that the `WindscribeService` named pipe allows `READ` and `WRITE` access to the `Everyone` group, meaning all authenticated users.

#### Checking WindscribeService Named Pipe Permissions
Confirming with `accesschk` we see that the Everyone group does indeed have `FILE_ALL_ACCESS` (All possible access rights) over the pipe.
```cmd-session
 accesschk.exe -accepteula -w \pipe\WindscribeService -v
```
From here, we could leverage these lax permissions to escalate privileges on the host to SYSTEM.


## Windows Privileges Overview
Rights an account is granted to do certain things on the machine.
Grand or Deny access to securable objects dependant on AD environment
Most privs disabled by default and are able to be enabled with an administrative cmd session.

### Windows Auth Process
Security principles are anything that can be authenticated by the windows OS including user and computer accounts, processes that run in the security context, and security groups.
Security principles are indentified with a [Security Identifier (SID)](https://docs.microsoft.com/en-us/troubleshoot/windows-server/identity/security-identifiers-in-windows) when a *SID* is created it remains assigned to that principle for its lifetime.

##### Process
1. User attempts to access a securable object 
2. Users *SID* is compared to  [Access Control Entries (ACEs)](https://docs.microsoft.com/en-us/windows/win32/secauthz/access-control-entries) within objects security descriptor (contains security info and access rights.)
3. Decision to Grant or Deny access is made.

![[Windows_Auth_Process.png]]