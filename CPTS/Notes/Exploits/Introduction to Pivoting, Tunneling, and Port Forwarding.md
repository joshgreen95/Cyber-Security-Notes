	s*Pivoting* is using a compromised machine to move to other networks through the compromised device.

Terms to describe compromised host used to *pivot* to a previously unreachable network.
- `Pivot Host`
- `Proxy`
- `Foothold`
- `Beach Head system`
- `Jump Host`

Used to defeat segmentation. Whereas *tunelling* is to encapsulate network traffic into another protocol and route traffic through it.

## Comparing Lateral Movement, Pivoting and Tunelling
### Lateral Movement
*Lateral Movement* is the technique used to further our access to additional `hosts`, `applications` and `services`.

Lateral movement can also help us gain access to specific domain resources we may need to elevate our privileges. This can often enable privilege
```
During an assessment, we gained initial access to the target environment and were able to gain control of the local administrator account. We performed a network scan and found three more Windows hosts in the network. We attempted to use the same local administrator credentials, and one of those devices shared the same administrator account. We used the credentials to move laterally to that other device, enabling us to compromise the domain further.
```

### Pivoting
Utilizing multiple hosts to cross `network` boundaries that we would not usually have access to. The goal is to move deeper into a network by compromising target host and infrastructure.

```
During one tricky engagement, the target had their network physically and logically separated. This separation made it difficult for us to move around and complete our objectives. We had to search the network and compromise a host that turned out to be the engineering workstation used to maintain and monitor equipment in the operational environment, submit reports, and perform other administrative duties in the enterprise environment. That host turned out to be dual-homed (having more than one physical NIC connected to different networks). Without it having access to both enterprise and operational networks, we would not have been able to pivot as we needed to complete our assessment.
```

_Look out for multiple nics?_ 

### Tunneling
Where we use common services and protocols to disguise traffic. (eg using HTTP to communicate with C&C Server). Obfuscation and Detection Avoidance.

```
One way we used Tunneling was to craft our traffic to hide in HTTP and HTTPS. This is a common way we maintained Command and Control (C2) of the hosts we had compromised within a network. We masked our instructions inside GET and POST requests that appeared as normal traffic and, to the untrained eye, would look like a web request or response to any old website. If the packet were formed properly, it would be forwarded to our Control server. If it were not, it would be redirected to another website, potentially throwing off the defender checking it out.
```


## The Network Behind Pivoting
### IP Addressing & NICs
Every computer communicating on a network needs an *IP*. *IP*s are usually obtained dynamically from a *DHCP* server. *IP* addresses can be static and commonly seen with:
- Servers
- Routers
- Switch virtual interfaces
- Printers
- And any devices that are providing critical services to the network

IP address assigned directly to *NIC* (`Network Interface Card`).
Always important to check for additional *NIC*s with
	`ifconfig` `Unix`
	`ipconfig` `Windows`

##### ifconfig
each NIC has an identifier (`eth`, `lo`, `tun0`)
- `tun0` Indicated a VPN

##### ipconfig
when network traffic is destined for an ip located on a different network, the computer will send traffic to its assigned *default gateway*

### Routing
`netstart -r` or `ip route`

Defining characteristic of a router is that it has a routing table that it uses to forward traffic based on the destination IP address.

*Routing Table* assists the system to make routing decisions. When a packet is created and has a destination before it leaves the computer, the routing table decides where to send it.
Any traffic destined for networks and not present in routing table will be sent to the default route. 

### Protocols, Services and Ports
*Protocols* are the rules that govern network communications. Many protocols have corresponding *ports* that act as identifiers.
An open *port* corresponds to an application we may be able to connect to.

## Dynamic Port Forwarding with SSH and SOCKS Tunelling
### Port Fowarding in Context
*Port Forwarding* is a technique that allows us to redirect a communication request from one port to another. 
*Port Forwarding* uses `TCP` as the primary communication layer. Different layers can be used to encapsulate forwarded traffic `SSH`, [[Definitions#SOCKS|SOCKS]]

### SSH Local Port Forwarding
![[SSH.png]]

If a service with an `SSH` port is open we can either request services directly from the open port or via `SSH`.

***EG***
```shell-session
PORT     STATE  SERVICE
22/tcp   open   ssh
3306/tcp closed mysql
```

We can either directly connect to `mysql` through `tcp 3306` or `SSH` into the machine and forward port `tcp 3306` to a port on our local machine eg:1234 via `SSH`
```
ssh -L 1234:localhost:3306 ubuntu@externalhost

ssh -L localport:localhost:externalporttoforward hostname@externalhost
```
*We can forward multiple ports at once*
We can then confirm the forwarded port with netstat
```
netstat -antp
```
### Setting up to Pivot
If we check `ifconfig` on linux host we can view if a server has multiple `NiCs` 
we can identify `Nics` from `ens` and loopback interfaces with `lo`.

We dont know which services lie on the other side of the pivot point. 
We need to scan the ip addresses which lie on the opposite side but we must first establish a route with dynamic port forwarding and pivot our network packets via the compromised server.

We cannot perform this scan directly from our attack host because it does not have roots to the network.

We can do this by starting a *SOCKS Listener* on our *localhost* and then configure `SSH` to forward that traffic via `SSH` to the alternate network after connecting to the target host.

This is called *SSH Tunelling* over *Socks Proxy*.

`SOCKS` stands for *Socket Secure*, a protocol that helps communicate with servers where you have firewall restrictions in place. 
in `SOCKS` the initial network traffic is generated  by the `SOCKS` client which then connects to the `SOCKS` server controlled by the user who wants to access a server on the client-side. Once connection is established, network traffic can be routed through the `SOCKS` server on behalf of the connected client.

This technique is used to circumvent restrictions put in place by firewalls, and allow an external entity to bypass a firewall and access a service in a fire-walled environment.
`SOCKS` proxies can pivot via creating a route to an external server from *NAT Networks*.

`SOCKS` proxies are currently of two types: `SOCKS4` and `SOCKs5`.
	`SOCKS4` doesn't provide any authentication and `UDP` support
	`SOCKS5` does. 

![[Pasted image 20250106051458.png]]

- Attack Host starts `SSH Client` and requests the `SSH Server` to allow it to send `TCP` data over `SSH` socket.
- `SSH Server` acknowledges and `SSH Client` then starts listening on *localhost:9050*
- Whatever data sent to *localhost:9050* will be broadcast to entire network over `SSH`

### Enabling Dynamic Port Forwarding with SSH
```shell-session
ssh -D 9050 ubuntu@10.129.202.64
```

`-D` argument requests `SSH` server to enable dynamic port forwarding.
Once enabled we need to use *proxychains* to route any tools packets over port `tcp 9050`.

*Proxychains* can route `TCP` connections through `SOCKS`, `TOR` and `HTTP/HTTPS`.

Using *Proxychains* we can hide the IP of our requesting host as the receiving host will only see the IP of our pivot machine.

*Proxychains* is often used to force an application's `TCP traffic` to go through hosted proxies like `SOCKS4`/`SOCKS5`, `TOR`, or `HTTP`/`HTTPS` proxies.

##### /etc/proxychains.conf

### Using Nmap with Proxychains
To use *proxychains* we just supersede any program with `proxychains`
*Proxychains* default port is `9050`

```shell-session
proxychains nmap -v -sn 172.16.5.1-200
```
`-sn` is a host discovery with no specified ports.


this is called *Socks Tunelling*.
We can only perform a *full TCP connect* (`nmap -sT`) scan over *proxychains* as it cannot understand partial packets and therefore cannot understand *UDP* scans.

*host-alive* checks may not work against windows targets as the Windows Defender Firewall blocks `ICMP` requests (*Pings*) by default.


### Enumerating the Windows Target with Proxychains
proxychains nmap -v -sn IP

```
proxychains nmap -v -Pn -sT IP
```
`-v verbose`
### Using Metasploit with Proxychains
```
proxychains msfconsole
```

### Using Xfreerdp with proxychains
```shell-session
proxychains xfreerdp /v:172.16.5.19 /u:victor /p:pass@123
```

***Always scan for RDP with metasploit, Service can be called something else***


## Remote/Reverse Port Forwarding with SSH

